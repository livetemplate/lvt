package e2e

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/chromedp/chromedp"
	e2etest "github.com/livetemplate/lvt/testing"
)

// TestPageModeURLRouting tests URL routing functionality in page mode
func TestPageModeURLRouting(t *testing.T) {
	t.Parallel() // Can run concurrently with Chrome pool

	tmpDir := t.TempDir()
	appDir := filepath.Join(tmpDir, "testapp")

	// Create app (production mode for Docker compatibility)
	if err := runLvtCommand(t, tmpDir, "new", "testapp"); err != nil {
		t.Fatalf("Failed to create app: %v", err)
	}

	// Enable DevMode BEFORE generating resources so DevMode=true gets baked into handler code
	enableDevMode(t, appDir)

	// Generate resource with page mode
	if err := runLvtCommand(t, appDir, "gen", "resource", "products", "name", "--edit-mode", "page"); err != nil {
		t.Fatalf("Failed to generate resource: %v", err)
	}

	// Run migration
	if err := runLvtCommand(t, appDir, "migration", "up"); err != nil {
		t.Fatalf("Failed to run migration: %v", err)
	}

	// Seed test data using parameterized queries for safety
	// Note: Generated app uses app.db by default, not testapp.db
	dbPath := filepath.Join(appDir, "app.db")
	seedErr := seedTestData(dbPath, []struct {
		SQL  string
		Args []interface{}
	}{
		{
			// Schema generated by `lvt gen products name` only has id, name, created_at
			SQL:  "INSERT INTO products (id, name, created_at) VALUES (?, ?, datetime('now'))",
			Args: []interface{}{"test-prod-1", "Test Product 1"},
		},
		{
			SQL:  "INSERT INTO products (id, name, created_at) VALUES (?, ?, datetime('now'))",
			Args: []interface{}{"test-prod-2", "Test Product 2"},
		},
	})
	if seedErr != nil {
		t.Logf("Warning: Failed to seed test data: %v (will rely on UI creation)", seedErr)
		// Don't fail here - UI creation will be attempted as fallback
	} else {
		t.Log("✅ Test data seeded successfully")
	}

	// Build Docker image and start container
	// Use stable image name to leverage Docker build cache across test runs
	port := allocateTestPort()
	imageName := "lvt-test-urlrouting:latest"

	// Write embedded client library before Docker build (DevMode already enabled before gen)
	writeEmbeddedClientLibrary(t, appDir)

	buildDockerImage(t, appDir, imageName)
	_ = runDockerContainer(t, imageName, port)

	// Wait for server to start
	serverURL := fmt.Sprintf("http://localhost:%d", port)
	waitForServer(t, serverURL, 10*time.Second)
	t.Logf("✅ Server ready on port %d", port)

	// Use Chrome from pool for parallel execution
	ctx, _, cleanup := GetPooledChrome(t)
	defer cleanup()

	testURL := fmt.Sprintf("%s/products", e2etest.GetChromeTestURL(port))
	t.Logf("Testing URL routing at: %s", testURL)

	// Setup: Verify seeded products are visible
	t.Run("Setup: Verify seeded products", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 45*time.Second)
		defer timeoutCancel()

		// Navigate to products page and wait for it to load
		// Increased timeout for Docker container environments
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(30*time.Second), // Increased for CDN loading + WebSocket init
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
		)
		if err != nil {
			t.Fatalf("Failed to load page: %v", err)
		}
		t.Log("✅ Products page loaded")

		// Check if seeded products are visible
		t.Log("Checking for seeded products...")
		var hasTable bool
		var rowCount int
		var linkHrefs string
		err = chromedp.Run(testCtx,
			// Check for table
			chromedp.Evaluate(`document.querySelector('table tbody') !== null`, &hasTable),
			chromedp.Evaluate(`document.querySelectorAll('table tbody tr').length`, &rowCount),
			// Get anchor link hrefs for later tests
			chromedp.Evaluate(`Array.from(document.querySelectorAll('table tbody tr a')).map(a => a.getAttribute('href')).join(',')`, &linkHrefs),
		)
		if err != nil {
			t.Fatalf("Failed to check for products: %v", err)
		}

		t.Logf("Has table: %v, Row count: %d, Links: %s", hasTable, rowCount, linkHrefs)

		if !hasTable || rowCount < 2 {
			// Seeded data not showing - dump page for debugging
			var bodyHTML string
			_ = chromedp.Run(testCtx, chromedp.Evaluate(`document.body.innerHTML`, &bodyHTML))
			t.Logf("DEBUG: Seeded data not visible. Body HTML (first 2000 chars):\n%s", bodyHTML[:min(2000, len(bodyHTML))])
			t.Fatalf("Expected at least 2 seeded products in table, got %d", rowCount)
		}

		t.Log("✅ Seeded products are visible in table")
	})

	// Test 1: URL updates when clicking resource
	t.Run("URL updates on resource click", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 45*time.Second)
		defer timeoutCancel()

		var currentURL string
		var linkExists bool

		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(30*time.Second), // Increased for CDN loading + WebSocket init
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			// Check if anchor link exists
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			// Debug: Dump HTML to see what's actually rendered
			var bodyHTML string
			_ = chromedp.Evaluate(`document.body.innerHTML`, &bodyHTML).Do(testCtx)
			t.Logf("DEBUG: Body HTML (first 1000 chars):\n%s", bodyHTML[:min(1000, len(bodyHTML))])

			var tableHTML string
			_ = chromedp.Evaluate(`document.querySelector('table')?.outerHTML || 'NO TABLE'`, &tableHTML).Do(testCtx)
			t.Logf("DEBUG: Table HTML:\n%s", tableHTML)

			t.Fatalf("No products available - seeded data not found (anchor links missing)")
		}

		// In page mode, clicking anchor link causes full page navigation
		// Don't wait for WebSocket after click since it's a new page load
		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Location(&currentURL),
		)
		if err != nil {
			t.Fatalf("Failed to click resource: %v", err)
		}

		// Check if URL changed to a product detail page (any ID format is valid)
		if !strings.HasPrefix(currentURL, testURL+"/") || currentURL == testURL || currentURL == testURL+"/" {
			t.Errorf("URL not updated to product detail. Expected %s/*, got %s", testURL, currentURL)
		} else {
			t.Logf("✅ URL updated to: %s", currentURL)
		}
	})

	// Test 2: Direct navigation to resource URL works
	t.Run("Direct navigation to resource URL", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 45*time.Second)
		defer timeoutCancel()

		var detailVisible bool
		// First, get a resource ID from the anchor link href
		var firstResourceHref string
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(30*time.Second), // Increased for CDN loading + WebSocket init
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a')?.getAttribute('href') || null`, &firstResourceHref),
		)
		if err != nil || firstResourceHref == "" {
			t.Fatalf("No resources available for direct navigation test - seeded data not found (err: %v, href: %s)", err, firstResourceHref)
		}

		// Extract resource ID from href (format: /products/product-xxx)
		parts := strings.Split(firstResourceHref, "/")
		if len(parts) < 3 {
			t.Fatalf("Invalid resource href format: %s (parts: %v)", firstResourceHref, parts)
		}
		firstResourceID := parts[len(parts)-1]

		// Now navigate directly to that resource
		directURL := fmt.Sprintf("%s/%s", testURL, firstResourceID)
		err = chromedp.Run(testCtx,
			chromedp.Navigate(directURL),
			waitFor(`document.readyState === 'complete'`, 5*time.Second),
			chromedp.Evaluate(`document.body.innerText.includes('Details') || document.body.innerText.includes('Back')`, &detailVisible),
		)
		if err != nil {
			t.Fatalf("Failed to navigate directly: %v", err)
		}

		if !detailVisible {
			t.Error("Detail view not shown when navigating directly to resource URL")
		} else {
			t.Log("✅ Direct navigation works")
		}
	})

	// Test 3: Browser back button returns to list
	t.Run("Browser back button works", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 45*time.Second)
		defer timeoutCancel()

		var linkExists bool
		var backToList bool

		// First check if anchor links exist
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(30*time.Second), // Increased for CDN loading + WebSocket init
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			t.Fatalf("No products available for back button test - seeded data not found")
		}

		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`history.back()`, nil),
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`document.querySelector('table') !== null`, &backToList),
		)
		if err != nil {
			t.Fatalf("Failed to test back button: %v", err)
		}

		if !backToList {
			t.Error("Browser back button did not return to list view")
		} else {
			t.Log("✅ Browser back button works")
		}
	})

	// Test 4: URL is at list path after back button
	t.Run("URL returns to list path after back", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 45*time.Second)
		defer timeoutCancel()

		var linkExists bool
		var finalURL string

		// First check if anchor links exist
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(30*time.Second), // Increased for CDN loading + WebSocket init
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			t.Fatalf("No products available for URL path test - seeded data not found")
		}

		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Evaluate(`history.back()`, nil),
			waitFor(`document.readyState === 'complete'`, 10*time.Second),
			chromedp.Location(&finalURL),
		)
		if err != nil {
			t.Fatalf("Failed to get URL after back: %v", err)
		}

		if !strings.HasSuffix(finalURL, "/products") && !strings.HasSuffix(finalURL, "/products/") {
			t.Errorf("URL not reset to list. Expected /products, got %s", finalURL)
		} else {
			t.Logf("✅ URL returned to list: %s", finalURL)
		}
	})

	t.Log("✅ All URL routing tests passed")
}
