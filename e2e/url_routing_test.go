package e2e

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/chromedp/chromedp"
	e2etest "github.com/livetemplate/lvt/testing"
)

// TestPageModeURLRouting tests URL routing functionality in page mode
func TestPageModeURLRouting(t *testing.T) {
	// Note: Not parallel because tests use chdirMutex and need sequential execution

	tmpDir := t.TempDir()
	appDir := filepath.Join(tmpDir, "testapp")

	// Create app with --dev flag
	if err := runLvtCommand(t, tmpDir, "new", "testapp", "--dev"); err != nil {
		t.Fatalf("Failed to create app: %v", err)
	}

	// Generate resource with page mode
	if err := runLvtCommand(t, appDir, "gen", "resource", "products", "name", "--edit-mode", "page"); err != nil {
		t.Fatalf("Failed to generate resource: %v", err)
	}

	// Setup go.mod for local livetemplate
	// Protected by mutex to prevent race with parallel tests changing directory
	chdirMutex.Lock()
	cwd, _ := os.Getwd()
	livetemplatePath := filepath.Join(cwd, "..", "..", "livetemplate")
	chdirMutex.Unlock()

	if err := runGoModTidy(t, appDir); err != nil {
		t.Fatalf("Failed to run go mod tidy: %v", err)
	}

	replaceCmd := exec.Command("go", "mod", "edit",
		"-replace", fmt.Sprintf("github.com/livetemplate/livetemplate=%s", livetemplatePath))
	replaceCmd.Dir = appDir
	if err := replaceCmd.Run(); err != nil {
		t.Fatalf("Failed to add replace directive: %v", err)
	}

	if err := runGoModTidy(t, appDir); err != nil {
		t.Fatalf("Failed to run go mod tidy after replace: %v", err)
	}

	// Copy client library using absolute path
	// Client is at monorepo root level, not inside livetemplate/
	monorepoRoot := filepath.Join(cwd, "..", "..")
	clientSrc := filepath.Join(monorepoRoot, "client", "dist", "livetemplate-client.browser.js")
	clientDst := filepath.Join(appDir, "livetemplate-client.js")
	clientContent, err := os.ReadFile(clientSrc)
	if err != nil {
		t.Fatalf("Failed to read client library: %v", err)
	}
	if err := os.WriteFile(clientDst, clientContent, 0644); err != nil {
		t.Fatalf("Failed to write client library: %v", err)
	}

	// Run migration
	if err := runLvtCommand(t, appDir, "migration", "up"); err != nil {
		t.Fatalf("Failed to run migration: %v", err)
	}

	// Seed test data using parameterized queries for safety
	// Note: Generated app uses app.db by default, not testapp.db
	dbPath := filepath.Join(appDir, "app.db")
	seedErr := seedTestData(dbPath, []struct {
		SQL  string
		Args []interface{}
	}{
		{
			// Schema generated by `lvt gen products name` only has id, name, created_at
			SQL:  "INSERT INTO products (id, name, created_at) VALUES (?, ?, datetime('now'))",
			Args: []interface{}{"test-prod-1", "Test Product 1"},
		},
		{
			SQL:  "INSERT INTO products (id, name, created_at) VALUES (?, ?, datetime('now'))",
			Args: []interface{}{"test-prod-2", "Test Product 2"},
		},
	})
	if seedErr != nil {
		t.Logf("Warning: Failed to seed test data: %v (will rely on UI creation)", seedErr)
		// Don't fail here - UI creation will be attempted as fallback
	} else {
		t.Log("✅ Test data seeded successfully")
	}

	// Start the app server - use unique port for parallel testing
	port := allocateTestPort()

	// Kill any process using this port before starting (cleanup from failed test runs)
	for attempt := 0; attempt < 5; attempt++ {
		killCmd := exec.Command("lsof", "-ti", fmt.Sprintf(":%d", port))
		if pidBytes, err := killCmd.Output(); err == nil && len(pidBytes) > 0 {
			pids := strings.TrimSpace(string(pidBytes))
			t.Logf("Found process on port %d (PIDs: %s), killing...", port, pids)
			for _, pid := range strings.Split(pids, "\n") {
				if pid != "" {
					killProcCmd := exec.Command("kill", "-9", pid)
					_ = killProcCmd.Run()
				}
			}
			time.Sleep(1 * time.Second) // Give OS time to release port
		} else {
			// No process found, port is free
			break
		}
	}

	// Verify port is actually free
	time.Sleep(500 * time.Millisecond)
	checkCmd := exec.Command("lsof", "-ti", fmt.Sprintf(":%d", port))
	if pidBytes, err := checkCmd.Output(); err == nil && len(pidBytes) > 0 {
		t.Logf("Warning: Port %d still in use after cleanup attempts", port)
	}

	// Build the server binary
	serverBinary := filepath.Join(tmpDir, "testapp-server")
	buildServerCmd := exec.Command("go", "build", "-o", serverBinary, "./cmd/testapp")
	buildServerCmd.Dir = appDir
	buildServerCmd.Env = append(os.Environ(), "GOWORK=off")
	buildOutput, buildErr := buildServerCmd.CombinedOutput()
	if buildErr != nil {
		t.Fatalf("Failed to build server: %v\nOutput: %s", buildErr, string(buildOutput))
	}

	serverCmd := exec.Command(serverBinary)
	serverCmd.Dir = appDir
	serverCmd.Env = append(os.Environ(), fmt.Sprintf("PORT=%d", port))
	serverCmd.Stdout = os.Stdout
	serverCmd.Stderr = os.Stderr

	if err := serverCmd.Start(); err != nil {
		t.Fatalf("Failed to start server: %v", err)
	}
	defer func() {
		if serverCmd.Process != nil {
			_ = serverCmd.Process.Kill()
			_ = serverCmd.Wait()
		}
	}()

	// Wait for server to start and verify it's actually running
	serverReady := false
	var lastErr error
	consecutiveSuccesses := 0
	const requiredSuccesses = 2

	for i := 0; i < 30; i++ {
		time.Sleep(quickPollDelay)

		resp, err := http.Get(fmt.Sprintf("http://localhost:%d/", port))
		if err == nil {
			if resp.StatusCode == 200 {
				resp.Body.Close()
				consecutiveSuccesses++
				if consecutiveSuccesses >= requiredSuccesses {
					// Extra time for WebSocket handler initialization
					time.Sleep(100 * time.Millisecond)
					serverReady = true
					t.Logf("✅ Server ready on port %d", port)
					break
				}
			} else {
				resp.Body.Close()
				lastErr = fmt.Errorf("server returned status %d", resp.StatusCode)
				consecutiveSuccesses = 0
			}
		} else {
			lastErr = err
			consecutiveSuccesses = 0
		}
	}
	if !serverReady {
		t.Fatalf("Server did not start within 6 seconds on port %d. Last error: %v", port, lastErr)
	}

	// Use isolated Chrome container for parallel execution
	ctx, cancel := getIsolatedChromeContext(t)
	defer cancel()

	testURL := fmt.Sprintf("%s/products", e2etest.GetChromeTestURL(port))
	t.Logf("Testing URL routing at: %s", testURL)

	// Setup: Verify seeded products are visible
	t.Run("Setup: Verify seeded products", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 30*time.Second)
		defer timeoutCancel()

		// Navigate to products page and wait for it to load
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(5*time.Second),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
		)
		if err != nil {
			t.Fatalf("Failed to load page: %v", err)
		}
		t.Log("✅ Products page loaded")

		// Check if seeded products are visible
		t.Log("Checking for seeded products...")
		var hasTable bool
		var rowCount int
		var linkHrefs string
		err = chromedp.Run(testCtx,
			// Check for table
			chromedp.Evaluate(`document.querySelector('table tbody') !== null`, &hasTable),
			chromedp.Evaluate(`document.querySelectorAll('table tbody tr').length`, &rowCount),
			// Get anchor link hrefs for later tests
			chromedp.Evaluate(`Array.from(document.querySelectorAll('table tbody tr a')).map(a => a.getAttribute('href')).join(',')`, &linkHrefs),
		)
		if err != nil {
			t.Fatalf("Failed to check for products: %v", err)
		}

		t.Logf("Has table: %v, Row count: %d, Links: %s", hasTable, rowCount, linkHrefs)

		if !hasTable || rowCount < 2 {
			// Seeded data not showing - dump page for debugging
			var bodyHTML string
			_ = chromedp.Run(testCtx, chromedp.Evaluate(`document.body.innerHTML`, &bodyHTML))
			t.Logf("DEBUG: Seeded data not visible. Body HTML (first 2000 chars):\n%s", bodyHTML[:min(2000, len(bodyHTML))])
			t.Fatalf("Expected at least 2 seeded products in table, got %d", rowCount)
		}

		t.Log("✅ Seeded products are visible in table")
	})

	// Test 1: URL updates when clicking resource
	t.Run("URL updates on resource click", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 30*time.Second)
		defer timeoutCancel()

		var currentURL string
		var linkExists bool

		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(5*time.Second),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			// Check if anchor link exists
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			// Debug: Dump HTML to see what's actually rendered
			var bodyHTML string
			_ = chromedp.Evaluate(`document.body.innerHTML`, &bodyHTML).Do(testCtx)
			t.Logf("DEBUG: Body HTML (first 1000 chars):\n%s", bodyHTML[:min(1000, len(bodyHTML))])

			var tableHTML string
			_ = chromedp.Evaluate(`document.querySelector('table')?.outerHTML || 'NO TABLE'`, &tableHTML).Do(testCtx)
			t.Logf("DEBUG: Table HTML:\n%s", tableHTML)

			t.Fatalf("No products available - seeded data not found (anchor links missing)")
		}

		// In page mode, clicking anchor link causes full page navigation
		// Don't wait for WebSocket after click since it's a new page load
		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Location(&currentURL),
		)
		if err != nil {
			t.Fatalf("Failed to click resource: %v", err)
		}

		// Check if URL changed to a product detail page (any ID format is valid)
		if !strings.HasPrefix(currentURL, testURL+"/") || currentURL == testURL || currentURL == testURL+"/" {
			t.Errorf("URL not updated to product detail. Expected %s/*, got %s", testURL, currentURL)
		} else {
			t.Logf("✅ URL updated to: %s", currentURL)
		}
	})

	// Test 2: Direct navigation to resource URL works
	t.Run("Direct navigation to resource URL", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 30*time.Second)
		defer timeoutCancel()

		var detailVisible bool
		// First, get a resource ID from the anchor link href
		var firstResourceHref string
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(5*time.Second),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a')?.getAttribute('href') || null`, &firstResourceHref),
		)
		if err != nil || firstResourceHref == "" {
			t.Fatalf("No resources available for direct navigation test - seeded data not found (err: %v, href: %s)", err, firstResourceHref)
		}

		// Extract resource ID from href (format: /products/product-xxx)
		parts := strings.Split(firstResourceHref, "/")
		if len(parts) < 3 {
			t.Fatalf("Invalid resource href format: %s (parts: %v)", firstResourceHref, parts)
		}
		firstResourceID := parts[len(parts)-1]

		// Now navigate directly to that resource
		directURL := fmt.Sprintf("%s/%s", testURL, firstResourceID)
		err = chromedp.Run(testCtx,
			chromedp.Navigate(directURL),
			waitFor(`document.readyState === 'complete'`, 5*time.Second),
			chromedp.Evaluate(`document.body.innerText.includes('Details') || document.body.innerText.includes('Back')`, &detailVisible),
		)
		if err != nil {
			t.Fatalf("Failed to navigate directly: %v", err)
		}

		if !detailVisible {
			t.Error("Detail view not shown when navigating directly to resource URL")
		} else {
			t.Log("✅ Direct navigation works")
		}
	})

	// Test 3: Browser back button returns to list
	t.Run("Browser back button works", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 30*time.Second)
		defer timeoutCancel()

		var linkExists bool
		var backToList bool

		// First check if anchor links exist
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(5*time.Second),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			t.Fatalf("No products available for back button test - seeded data not found")
		}

		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`history.back()`, nil),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`document.querySelector('table') !== null`, &backToList),
		)
		if err != nil {
			t.Fatalf("Failed to test back button: %v", err)
		}

		if !backToList {
			t.Error("Browser back button did not return to list view")
		} else {
			t.Log("✅ Browser back button works")
		}
	})

	// Test 4: URL is at list path after back button
	t.Run("URL returns to list path after back", func(t *testing.T) {
		// Create fresh browser context for this subtest
		testCtx, cancel := chromedp.NewContext(ctx)
		defer cancel()
		testCtx, timeoutCancel := context.WithTimeout(testCtx, 30*time.Second)
		defer timeoutCancel()

		var linkExists bool
		var finalURL string

		// First check if anchor links exist
		err := chromedp.Run(testCtx,
			chromedp.Navigate(testURL),
			e2etest.WaitForWebSocketReady(5*time.Second),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`document.querySelector('table tbody tr a') !== null`, &linkExists),
		)
		if err != nil {
			t.Fatalf("Failed to check for links: %v", err)
		}

		if !linkExists {
			t.Fatalf("No products available for URL path test - seeded data not found")
		}

		err = chromedp.Run(testCtx,
			chromedp.Click(`table tbody tr a`, chromedp.ByQuery),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Evaluate(`history.back()`, nil),
			waitFor(`document.readyState === 'complete'`, 3*time.Second),
			chromedp.Location(&finalURL),
		)
		if err != nil {
			t.Fatalf("Failed to get URL after back: %v", err)
		}

		if !strings.HasSuffix(finalURL, "/products") && !strings.HasSuffix(finalURL, "/products/") {
			t.Errorf("URL not reset to list. Expected /products, got %s", finalURL)
		} else {
			t.Logf("✅ URL returned to list: %s", finalURL)
		}
	})

	t.Log("✅ All URL routing tests passed")
}
