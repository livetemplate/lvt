package [[.PackageName]]

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os/exec"
	"strings"
	"testing"
	"time"

	"github.com/gorilla/websocket"
	e2etest "github.com/livetemplate/livetemplate/cmd/lvt/testing"
)

func TestWebSocketBasic(t *testing.T) {
	// Get a free port
	port, err := e2etest.GetFreePort()
	if err != nil {
		t.Fatalf("Failed to get free port: %v", err)
	}

	portStr := fmt.Sprintf("%d", port)
	serverURL := fmt.Sprintf("http://localhost:%s", portStr)
	wsURL := fmt.Sprintf("ws://localhost:%s/[[.ViewNameLower]]", portStr)

	// Start server on dynamic port
	cmd := exec.Command("go", "run", "../../cmd/[[.ModuleName]]/main.go")
	cmd.Env = append([]string{"PORT=" + portStr}, cmd.Environ()...)

	serverLogs := &bytes.Buffer{}
	cmd.Stdout = serverLogs
	cmd.Stderr = serverLogs

	if err := cmd.Start(); err != nil {
		t.Fatalf("Failed to start server: %v", err)
	}
	defer func() {
		cmd.Process.Kill()
		t.Logf("=== SERVER LOGS ===\n%s", serverLogs.String())
	}()

	// Wait for server
	time.Sleep(2 * time.Second)
	for i := 0; i < 30; i++ {
		if resp, err := http.Get(serverURL); err == nil {
			resp.Body.Close()
			break
		}
		time.Sleep(100 * time.Millisecond)
	}

	t.Log("Server is up, trying to connect WebSocket...")

	// Try to connect
	dialer := websocket.Dialer{}
	conn, resp, err := dialer.Dial(wsURL, nil)
	if err != nil {
		t.Fatalf("Failed to connect: %v, response: %v", err, resp)
	}
	defer conn.Close()

	t.Log("WebSocket connected successfully!")

	// Read first message (initial tree)
	_, msg, err := conn.ReadMessage()
	if err != nil {
		t.Fatalf("Failed to read message: %v", err)
	}

	t.Logf("Received initial message, length: %d bytes", len(msg))
	t.Logf("Initial message: %s", string(msg))

	// Verify initial state
	if !strings.Contains(string(msg), "[[.ViewName]]") {
		t.Error("Initial message should contain '[[.ViewName]]'")
	}

	t.Log("âœ… WebSocket test passed!")
}
