package auth

// Auth handler for LiveTemplate applications.
// Routes are automatically registered in main.go when running `lvt gen auth`.
//
// Available routes:
//   - /auth          - Main authentication page (login, register, forgot password)
//   - /auth/logout   - Logout endpoint
{{- if .EnableMagicLink }}
//   - /auth/magic    - Magic link verification
{{- end }}
{{- if .EnablePasswordReset }}
//   - /auth/reset    - Password reset
{{- end }}
{{- if .EnableEmailConfirm }}
//   - /auth/confirm  - Email confirmation
{{- end }}
//
// Configuration:
//   - Set BASE_URL environment variable for email links (default: http://localhost:8080)
//   - By default, emails are logged to console. Replace email.NewConsoleEmailSender()
//     in Handler() with your production email sender.
//
// For protected routes, use the auth middleware or GetCurrentUser:
//
//	controller := auth.New{{.StructName}}Controller(queries, emailSender, baseURL)
//	user, err := controller.GetCurrentUser(r)
//	if err != nil {
//		http.Redirect(w, r, "/auth", http.StatusSeeOther)
//		return
//	}
//	// ... user is authenticated

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"{{.ModuleName}}/database/models"
	"github.com/livetemplate/lvt/pkg/cookie"
	"github.com/livetemplate/lvt/pkg/email"
	"github.com/livetemplate/lvt/pkg/flash"
	{{- if .EnablePassword }}
	"github.com/livetemplate/lvt/pkg/password"
	{{- end }}
	"github.com/livetemplate/lvt/pkg/security"
	"github.com/livetemplate/lvt/pkg/token"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/livetemplate/livetemplate"
)

var validate = validator.New()

// {{.StructName}}Controller is a singleton that holds dependencies
type {{.StructName}}Controller struct {
	queries     *models.Queries
	emailSender email.EmailSender
	baseURL     string
}

// {{.StructName}}State is pure data, cloned per session
type {{.StructName}}State struct {
	View          string `json:"view"` // "login", "register", "forgot", "reset", "confirm"
	Email         string `json:"email"`
	Password      string `json:"password"`
	Token         string `json:"token"`
	ShowMagicLink bool   `json:"show_magic_link"`
	ShowPassword  bool   `json:"show_password"`
	FlashError    string `json:"flash_error"`
	FlashSuccess  string `json:"flash_success"`
}

func New{{.StructName}}Controller(queries *models.Queries, emailSender email.EmailSender, baseURL string) *{{.StructName}}Controller {
	return &{{.StructName}}Controller{
		queries:     queries,
		emailSender: emailSender,
		baseURL:     baseURL,
	}
}

func New{{.StructName}}State() *{{.StructName}}State {
	return &{{.StructName}}State{
		View:          "login",
		ShowMagicLink: {{.EnableMagicLink}},
		ShowPassword:  {{.EnablePassword}},
	}
}

// Error messages for query parameter codes (from HTTP redirects)
var errorMessages = map[string]string{
	"invalid_form":            "Invalid form submission",
	"email_password_required": "Email and password are required",
	"invalid_credentials":     "Invalid email or password",
	"email_not_confirmed":     "Please confirm your email before logging in",
	"login_failed":            "Login failed. Please try again.",
	"invalid_token":           "Invalid or expired token",
	"expired_token":           "Token has expired",
	"confirm_failed":          "Failed to confirm email",
}

var successMessages = map[string]string{
	"email_confirmed": "Email confirmed! You can now log in.",
	"password_reset":  "Password reset successfully. You can now log in.",
}

// Mount is called once per session to initialize state.
// Flash messages are handled via cookies in the HTTP handler for proper one-time display.
func (c *{{.StructName}}Controller) Mount(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	return state, nil
}

// SwitchView handles the "switch_view" action to switch between login/register/forgot views
func (c *{{.StructName}}Controller) SwitchView(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	view := ctx.GetString("view")
	if view != "" {
		state.View = view
		// Flash messages are cleared automatically after each render
	}
	return state, nil
}

// SwitchToLogin switches to the login view
func (c *{{.StructName}}Controller) SwitchToLogin(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	state.View = "login"
	return state, nil
}

// SwitchToRegister switches to the register view
func (c *{{.StructName}}Controller) SwitchToRegister(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	state.View = "register"
	return state, nil
}

// SwitchToForgot switches to the forgot password view
func (c *{{.StructName}}Controller) SwitchToForgot(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	state.View = "forgot"
	return state, nil
}

{{- if .EnablePassword }}

type RegisterInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8"`
}

// Register handles the "register" action for user registration
func (c *{{.StructName}}Controller) Register(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input RegisterInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.FlashError = "Email and password are required"
		return state, nil
	}

	// Check if user already exists
	existing, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err == nil && existing.ID != "" {
		state.FlashError = "Email already registered"
		return state, nil
	}

	// Hash password
	hashedPassword, err := password.Hash(input.Password)
	if err != nil {
		state.FlashError = "Failed to process password"
		log.Printf("Password hash error: %v", err)
		return state, nil
	}

	// Create user
	userID := uuid.New().String()
	now := time.Now()

	_, err = c.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
		ID:             userID,
		Email:          input.Email,
		HashedPassword: hashedPassword,
		CreatedAt:      now,
		UpdatedAt:      now,
	})
	if err != nil {
		state.FlashError = "Failed to create account"
		log.Printf("Create user error: %v", err)
		return state, nil
	}

	{{- if .EnableEmailConfirm }}
	// Send confirmation email
	token, err := c.generateToken(userID, "confirm", 24*time.Hour)
	if err != nil {
		state.FlashError = "Account created but failed to send confirmation email"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	confirmURL := fmt.Sprintf("%s/auth/confirm?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Confirm your email",
		fmt.Sprintf("Click here to confirm your email: %s", confirmURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	state.FlashSuccess = "Account created! Please check your email to confirm your account."
	{{- else }}
	state.FlashSuccess = "Account created! You can now log in."
	{{- end }}

	state.View = "login"
	state.Email = ""
	state.Password = ""

	return state, nil
}

type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

// Login handles the "login" action for password-based login
func (c *{{.StructName}}Controller) Login(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input LoginInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.FlashError = "Email and password are required"
		return state, nil
	}

	// Get user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		state.FlashError = "Invalid email or password"
		return state, nil
	}

	{{- if .EnableEmailConfirm }}
	// Check if email is confirmed
	if !user.ConfirmedAt.Valid {
		state.FlashError = "Please confirm your email before logging in"
		return state, nil
	}
	{{- end }}

	// Verify password
	if !password.Verify(input.Password, user.HashedPassword) {
		state.FlashError = "Invalid email or password"
		return state, nil
	}

	// Create session token
	token, err := c.generateToken(user.ID, "session", 30*24*time.Hour) // 30 days
	if err != nil {
		state.FlashError = "Login failed"
		log.Printf("Generate session token error: %v", err)
		return state, nil
	}

	// Set session cookie using Context API
	// NOTE: This may fail over WebSocket - the login form should use HTTP POST instead
	if err := ctx.SetCookie(&http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    token,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60, // 30 days
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	}); err != nil {
		// Cookie can't be set over WebSocket - this is expected
		// The login form should use HTTP POST via /auth/login endpoint
		log.Printf("Set cookie error: %v", err)
		{{- if .EnableMagicLink }}
		state.FlashError = "Login via WebSocket not supported. Please use the magic link option."
		{{- else }}
		state.FlashError = "Login failed. Please try again."
		{{- end }}
		return state, nil
	}

	// Redirect to home using Context API
	if err := ctx.Redirect("/", http.StatusSeeOther); err != nil {
		log.Printf("Redirect warning: %v", err)
		// Don't fail on redirect error - cookie was set successfully
	}

	return state, nil
}

{{- end }}

{{- if .EnableMagicLink }}

type MagicLinkInput struct {
	Email string `json:"email" validate:"required,email"`
}

// MagicLink handles the "magic_link" action to send a magic link email
func (c *{{.StructName}}Controller) MagicLink(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input MagicLinkInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.FlashError = "Email is required"
		return state, nil
	}

	// Get or create user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Create new user
		userID := uuid.New().String()
		now := time.Now()
		user, err = c.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
			ID:        userID,
			Email:     input.Email,
			{{- if .EnablePassword }}
			HashedPassword: "", // No password for magic-link only users
			{{- end }}
			CreatedAt: now,
			UpdatedAt: now,
		})
		if err != nil {
			state.FlashError = "Failed to process request"
			log.Printf("Create user error: %v", err)
			return state, nil
		}
	}

	// Generate magic link token
	token, err := c.generateToken(user.ID, "magic", 15*time.Minute)
	if err != nil {
		state.FlashError = "Failed to send magic link"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	// Send magic link email
	magicURL := fmt.Sprintf("%s/auth/magic?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Your login link",
		fmt.Sprintf("Click here to log in: %s\n\nThis link expires in 15 minutes.", magicURL),
	)
	if err != nil {
		state.FlashError = "Failed to send magic link"
		log.Printf("Send email error: %v", err)
		return state, nil
	}

	state.FlashSuccess = "Check your email for a login link!"
	state.Email = ""
	return state, nil
}

// HandleMagicLinkVerify verifies magic link token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleMagicLinkVerify(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Delete the magic link token (one-time use)
	c.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Create session token
	sessionToken, err := c.generateToken(userToken.{{.StructName}}ID, "session", 30*24*time.Hour)
	if err != nil {
		log.Printf("Generate session token error: %v", err)
		http.Redirect(w, r, "/auth?error=login_failed", http.StatusSeeOther)
		return
	}

	// Set session cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    sessionToken,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// Clear LiveTemplate session to force fresh state on home page
	cookie.ClearLiveTemplateSession(w)

	// Redirect to home
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

{{- end }}

{{- if .EnablePasswordReset }}

type ForgotPasswordInput struct {
	Email string `json:"email" validate:"required,email"`
}

// ForgotPassword handles the "forgot_password" action to send a password reset email
func (c *{{.StructName}}Controller) ForgotPassword(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input ForgotPasswordInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.FlashError = "Email is required"
		return state, nil
	}

	// Get user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Don't reveal if email exists or not for security
		state.FlashSuccess = "If that email is registered, you'll receive a password reset link shortly."
		state.Email = ""
		return state, nil
	}

	// Generate reset token
	token, err := c.generateToken(user.ID, "reset", 1*time.Hour)
	if err != nil {
		state.FlashError = "Failed to send reset link"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	// Send reset email
	resetURL := fmt.Sprintf("%s/auth/reset?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Reset your password",
		fmt.Sprintf("Click here to reset your password: %s\n\nThis link expires in 1 hour.", resetURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	state.FlashSuccess = "If that email is registered, you'll receive a password reset link shortly."
	state.Email = ""
	return state, nil
}

// HandleResetPassword resets user password with token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleResetPassword(w http.ResponseWriter, r *http.Request) {
	if r.Method == "GET" {
		// Show reset form
		token := r.URL.Query().Get("token")
		if token == "" {
			http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
			return
		}

		// Verify token exists and not expired
		_, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
			Token:     token,
			ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
		})
		if err != nil {
			http.Redirect(w, r, "/auth?error=expired_token", http.StatusSeeOther)
			return
		}

		// Render reset password form (simplified - in production use proper template)
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head><title>Reset Password</title></head>
<body>
<h2>Reset Password</h2>
<form method="POST">
	<input type="hidden" name="token" value="%s">
	<label>New Password: <input type="password" name="password" required minlength="8"></label><br>
	<button type="submit">Reset Password</button>
</form>
</body>
</html>
		`, token)
		return
	}

	// Handle POST - update password
	if err := r.ParseForm(); err != nil {
		http.Redirect(w, r, "/auth?error=invalid_request", http.StatusSeeOther)
		return
	}

	token := r.FormValue("token")
	newPassword := r.FormValue("password")

	if token == "" || newPassword == "" {
		http.Redirect(w, r, "/auth?error=missing_fields", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Hash new password
	hashedPassword, err := password.Hash(newPassword)
	if err != nil {
		log.Printf("Password hash error: %v", err)
		http.Redirect(w, r, "/auth?error=password_failed", http.StatusSeeOther)
		return
	}

	// Update password
	err = c.queries.Update{{.StructName}}Password(context.Background(), models.Update{{.StructName}}PasswordParams{
		HashedPassword: hashedPassword,
		UpdatedAt:      time.Now(),
		ID:             userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Update password error: %v", err)
		http.Redirect(w, r, "/auth?error=update_failed", http.StatusSeeOther)
		return
	}

	// Delete all reset tokens for this user
	c.queries.Delete{{.StructName}}TokensByContext(context.Background(), models.Delete{{.StructName}}TokensByContextParams{
		{{.StructName}}ID: userToken.{{.StructName}}ID,
		Context:          "reset",
	})

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=password_reset", http.StatusSeeOther)
}

{{- end }}

{{- if .EnableEmailConfirm }}

// HandleConfirmEmail confirms user email with token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleConfirmEmail(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Confirm user
	now := time.Now()
	err = c.queries.Confirm{{.StructName}}(context.Background(), models.Confirm{{.StructName}}Params{
		ConfirmedAt: sql.NullTime{Time: now, Valid: true},
		UpdatedAt:   now,
		ID:          userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Confirm user error: %v", err)
		http.Redirect(w, r, "/auth?error=confirm_failed", http.StatusSeeOther)
		return
	}

	// Delete the confirmation token
	c.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=email_confirmed", http.StatusSeeOther)
}

{{- end }}

// HandlePasswordLogin handles password-based login via HTTP POST
// This is needed because cookies cannot be set over WebSocket
func (c *{{.StructName}}Controller) HandlePasswordLogin(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Redirect(w, r, "/auth", http.StatusSeeOther)
		return
	}

	// CSRF protection: validate Origin/Referer header matches request host
	if !security.ValidateOriginAllowEmpty(r) {
		log.Printf("CSRF protection: Origin/Referer mismatch for host %s", r.Host)
		http.Redirect(w, r, "/auth?error=invalid_form", http.StatusSeeOther)
		return
	}

	// Parse form data
	if err := r.ParseForm(); err != nil {
		http.Redirect(w, r, "/auth?error=invalid_form", http.StatusSeeOther)
		return
	}

	email := r.FormValue("email")
	pass := r.FormValue("password")

	if email == "" || pass == "" {
		http.Redirect(w, r, "/auth?error=email_password_required", http.StatusSeeOther)
		return
	}

	// Get user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), email)
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_credentials", http.StatusSeeOther)
		return
	}

	{{- if .EnableEmailConfirm }}
	// Check if email is confirmed
	if !user.ConfirmedAt.Valid {
		http.Redirect(w, r, "/auth?error=email_not_confirmed", http.StatusSeeOther)
		return
	}
	{{- end }}

	// Verify password
	if !password.Verify(pass, user.HashedPassword) {
		http.Redirect(w, r, "/auth?error=invalid_credentials", http.StatusSeeOther)
		return
	}

	// Create session token
	tok, err := c.generateToken(user.ID, "session", 30*24*time.Hour)
	if err != nil {
		log.Printf("Generate session token error: %v", err)
		http.Redirect(w, r, "/auth?error=login_failed", http.StatusSeeOther)
		return
	}

	// Set session cookie (30 days) - Secure flag is auto-detected from request
	cookie.SetSession(w, r, "{{.TableName}}_token", tok, 30)

	// Redirect to home
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

// HandleLogout handles user logout (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleLogout(w http.ResponseWriter, r *http.Request) {
	// Get session token from cookie and delete from database
	if tok := cookie.Get(r, "{{.TableName}}_token"); tok != "" {
		c.queries.Delete{{.StructName}}Token(context.Background(), tok)
	}

	// Clear auth cookie
	cookie.ClearSecure(w, "{{.TableName}}_token")

	// Clear LiveTemplate session cookie to force fresh state on home page
	cookie.ClearLiveTemplateSession(w)

	// Redirect to home
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

// generateToken creates a random token and stores it
func (c *{{.StructName}}Controller) generateToken(userID, tokenContext string, duration time.Duration) (string, error) {
	// Generate random token
	tok, err := token.Generate()
	if err != nil {
		return "", err
	}

	// Store token
	tokenID := uuid.New().String()
	now := time.Now()
	expiresAt := sql.NullTime{Time: now.Add(duration), Valid: true}

	_, err = c.queries.Create{{.StructName}}Token(context.Background(), models.Create{{.StructName}}TokenParams{
		ID:        tokenID,
		{{.StructName}}ID:   userID,
		Token:     tok,
		Context:   tokenContext,
		CreatedAt: now,
		ExpiresAt: expiresAt,
	})
	if err != nil {
		return "", err
	}

	return tok, nil
}

// GetCurrentUser returns the authenticated user or nil
func (c *{{.StructName}}Controller) GetCurrentUser(r *http.Request) (*models.{{.StructName}}, error) {
	tok := cookie.Get(r, "{{.TableName}}_token")
	if tok == "" {
		return nil, http.ErrNoCookie
	}

	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     tok,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		return nil, err
	}

	user, err := c.queries.Get{{.StructName}}ByID(context.Background(), userToken.{{.StructName}}ID)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Handler creates an http.Handler for the auth LiveTemplate view
// It sets up the controller and returns a handler that can be registered with http.Handle
func Handler(queries *models.Queries) http.Handler {
	// Get base URL from environment, or use default for development
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}

	// Use console email sender by default (logs emails to console)
	// Replace with production email sender in your deployment
	emailSender := email.NewConsoleEmailSender()

	// Create controller with dependencies
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)

	// Parse the template
	baseTmpl := livetemplate.Must(livetemplate.New("auth",
		livetemplate.WithDevMode(false),
	))
	if _, err := baseTmpl.ParseFiles("app/auth/auth.tmpl"); err != nil {
		log.Fatalf("Failed to parse auth template: %v", err)
	}

	// Return handler that clones template per-request
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Handle error/success query params by setting flash cookies and redirecting to clean URL
		errCode := r.URL.Query().Get("error")
		successCode := r.URL.Query().Get("success")

		if errCode != "" || successCode != "" {
			// Clear livetemplate-id to force new session on next request
			cookie.ClearLiveTemplateSession(w)

			// Set flash message from error/success code
			if errCode != "" {
				if msg, ok := errorMessages[errCode]; ok {
					flash.Error(w, msg)
				}
			}
			if successCode != "" {
				if msg, ok := successMessages[successCode]; ok {
					flash.Success(w, msg)
				}
			}

			// Set marker so we know flash was triggered (for one-time display)
			flash.SetPending(w)

			// Redirect to clean URL
			http.Redirect(w, r, "/auth", http.StatusSeeOther)
			return
		}

		tmpl, err := baseTmpl.Clone()
		if err != nil {
			log.Printf("Failed to clone auth template: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}

		// Only process flash logic for GET requests (not HEAD/WebSocket preflight)
		if r.Method == "GET" {
			hasFlashPending := flash.IsPending(r)
			hasSession := cookie.Get(r, "livetemplate-id") != ""

			// If we have a session but no flash_pending marker, this is a reload
			// Force new session to clear any stale flash from previous session
			if hasSession && !hasFlashPending {
				cookie.ClearLiveTemplateSession(w)
			}

			// Clear the flash_pending marker after first use
			if hasFlashPending {
				flash.ClearPending(w)
			}
		}

		// Read and clear flash cookies, set in initial state
		state := New{{.StructName}}State()
		msgs := flash.GetAll(r, w)
		state.FlashError = msgs.Error
		state.FlashSuccess = msgs.Success

		tmpl.Handle(controller, livetemplate.AsState(state)).ServeHTTP(w, r)
	})
}

// LogoutHandler returns an http.Handler for the logout endpoint
func LogoutHandler(queries *models.Queries) http.Handler {
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}
	emailSender := email.NewConsoleEmailSender()
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)
	return http.HandlerFunc(controller.HandleLogout)
}

{{- if .EnableMagicLink }}
// MagicLinkHandler returns an http.Handler for magic link verification
func MagicLinkHandler(queries *models.Queries) http.Handler {
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}
	emailSender := email.NewConsoleEmailSender()
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)
	return http.HandlerFunc(controller.HandleMagicLinkVerify)
}
{{- end }}

{{- if .EnablePasswordReset }}
// ResetPasswordHandler returns an http.Handler for password reset
func ResetPasswordHandler(queries *models.Queries) http.Handler {
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}
	emailSender := email.NewConsoleEmailSender()
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)
	return http.HandlerFunc(controller.HandleResetPassword)
}
{{- end }}

{{- if .EnableEmailConfirm }}
// ConfirmEmailHandler returns an http.Handler for email confirmation
func ConfirmEmailHandler(queries *models.Queries) http.Handler {
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}
	emailSender := email.NewConsoleEmailSender()
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)
	return http.HandlerFunc(controller.HandleConfirmEmail)
}
{{- end }}

// PasswordLoginHandler returns an http.Handler for password-based login
func PasswordLoginHandler(queries *models.Queries) http.Handler {
	baseURL := "http://localhost:8080"
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		baseURL = envURL
	}
	emailSender := email.NewConsoleEmailSender()
	controller := New{{.StructName}}Controller(queries, emailSender, baseURL)
	return http.HandlerFunc(controller.HandlePasswordLogin)
}
