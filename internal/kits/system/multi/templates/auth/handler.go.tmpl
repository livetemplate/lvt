package auth

// Auth handler for LiveTemplate applications.
// Routes are automatically registered in main.go when running `lvt gen auth`.
//
// Available routes:
//   - /auth          - Main authentication page (login, register, forgot password)
//   - /auth/logout   - Logout endpoint
{{- if .EnableMagicLink }}
//   - /auth/magic    - Magic link verification
{{- end }}
{{- if .EnablePasswordReset }}
//   - /auth/reset    - Password reset
{{- end }}
{{- if .EnableEmailConfirm }}
//   - /auth/confirm  - Email confirmation
{{- end }}
//
// Configuration:
//   - Set BASE_URL environment variable for email links (default: http://localhost:8080)
//   - By default, emails are logged to console. Replace email.NewConsoleEmailSender()
//     in Handler() with your production email sender.
//
// For protected routes, use the auth middleware or GetCurrentUser:
//
//	controller := auth.New{{.StructName}}Controller(queries, emailSender, baseURL)
//	user, err := controller.GetCurrentUser(r)
//	if err != nil {
//		http.Redirect(w, r, "/auth", http.StatusSeeOther)
//		return
//	}
//	// ... user is authenticated

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"{{.ModuleName}}/database/models"
	"{{.ModuleName}}/shared/email"
	{{- if .EnablePassword }}
	"{{.ModuleName}}/shared/password"
	{{- end }}
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/livetemplate/livetemplate"
)

var validate = validator.New()

// {{.StructName}}Controller is a singleton that holds dependencies
type {{.StructName}}Controller struct {
	queries     *models.Queries
	emailSender email.EmailSender
	baseURL     string
}

// {{.StructName}}State is pure data, cloned per session
type {{.StructName}}State struct {
	View          string `json:"view"` // "login", "register", "forgot", "reset", "confirm"
	Email         string `json:"email"`
	Password      string `json:"password"`
	Error         string `json:"error"`
	Success       string `json:"success"`
	Token         string `json:"token"`
	ShowMagicLink bool   `json:"show_magic_link"`
	ShowPassword  bool   `json:"show_password"`
}

func New{{.StructName}}Controller(queries *models.Queries, emailSender email.EmailSender, baseURL string) *{{.StructName}}Controller {
	return &{{.StructName}}Controller{
		queries:     queries,
		emailSender: emailSender,
		baseURL:     baseURL,
	}
}

func New{{.StructName}}State() *{{.StructName}}State {
	return &{{.StructName}}State{
		View:          "login",
		ShowMagicLink: {{.EnableMagicLink}},
		ShowPassword:  {{.EnablePassword}},
	}
}

// SwitchView handles the "switch_view" action to switch between login/register/forgot views
func (c *{{.StructName}}Controller) SwitchView(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	view := ctx.GetString("view")
	if view != "" {
		state.View = view
		state.Error = ""
		state.Success = ""
	}
	return state, nil
}

{{- if .EnablePassword }}

type RegisterInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8"`
}

// Register handles the "register" action for user registration
func (c *{{.StructName}}Controller) Register(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input RegisterInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.Error = "Email and password are required"
		return state, nil
	}

	// Check if user already exists
	existing, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err == nil && existing.ID != "" {
		state.Error = "Email already registered"
		return state, nil
	}

	// Hash password
	hashedPassword, err := password.Hash(input.Password)
	if err != nil {
		state.Error = "Failed to process password"
		log.Printf("Password hash error: %v", err)
		return state, nil
	}

	// Create user
	userID := uuid.New().String()
	now := time.Now()

	_, err = c.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
		ID:             userID,
		Email:          input.Email,
		HashedPassword: hashedPassword,
		CreatedAt:      now,
		UpdatedAt:      now,
	})
	if err != nil {
		state.Error = "Failed to create account"
		log.Printf("Create user error: %v", err)
		return state, nil
	}

	{{- if .EnableEmailConfirm }}
	// Send confirmation email
	token, err := c.generateToken(userID, "confirm", 24*time.Hour)
	if err != nil {
		state.Error = "Account created but failed to send confirmation email"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	confirmURL := fmt.Sprintf("%s/auth/confirm?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Confirm your email",
		fmt.Sprintf("Click here to confirm your email: %s", confirmURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	state.Success = "Account created! Please check your email to confirm your account."
	{{- else }}
	state.Success = "Account created! You can now log in."
	{{- end }}

	state.View = "login"
	state.Email = ""
	state.Password = ""
	state.Error = ""

	return state, nil
}

type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

// Login handles the "login" action for password-based login
func (c *{{.StructName}}Controller) Login(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input LoginInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.Error = "Email and password are required"
		return state, nil
	}

	// Get user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		state.Error = "Invalid email or password"
		return state, nil
	}

	{{- if .EnableEmailConfirm }}
	// Check if email is confirmed
	if !user.ConfirmedAt.Valid {
		state.Error = "Please confirm your email before logging in"
		return state, nil
	}
	{{- end }}

	// Verify password
	if !password.Verify(input.Password, user.HashedPassword) {
		state.Error = "Invalid email or password"
		return state, nil
	}

	// Create session token
	token, err := c.generateToken(user.ID, "session", 30*24*time.Hour) // 30 days
	if err != nil {
		state.Error = "Login failed"
		log.Printf("Generate session token error: %v", err)
		return state, nil
	}

	// Set session cookie using Context API
	if err := ctx.SetCookie(&http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    token,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60, // 30 days
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	}); err != nil {
		state.Error = "Login failed"
		log.Printf("Set cookie error: %v", err)
		return state, nil
	}

	// Redirect to home using Context API
	if err := ctx.Redirect("/", http.StatusSeeOther); err != nil {
		state.Error = "Login failed"
		log.Printf("Redirect error: %v", err)
		return state, nil
	}

	return state, nil
}

{{- end }}

{{- if .EnableMagicLink }}

type MagicLinkInput struct {
	Email string `json:"email" validate:"required,email"`
}

// MagicLink handles the "magic_link" action to send a magic link email
func (c *{{.StructName}}Controller) MagicLink(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input MagicLinkInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.Error = "Email is required"
		return state, nil
	}

	// Get or create user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Create new user
		userID := uuid.New().String()
		now := time.Now()
		user, err = c.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
			ID:        userID,
			Email:     input.Email,
			{{- if .EnablePassword }}
			HashedPassword: "", // No password for magic-link only users
			{{- end }}
			CreatedAt: now,
			UpdatedAt: now,
		})
		if err != nil {
			state.Error = "Failed to process request"
			log.Printf("Create user error: %v", err)
			return state, nil
		}
	}

	// Generate magic link token
	token, err := c.generateToken(user.ID, "magic", 15*time.Minute)
	if err != nil {
		state.Error = "Failed to send magic link"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	// Send magic link email
	magicURL := fmt.Sprintf("%s/auth/magic?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Your login link",
		fmt.Sprintf("Click here to log in: %s\n\nThis link expires in 15 minutes.", magicURL),
	)
	if err != nil {
		state.Error = "Failed to send magic link"
		log.Printf("Send email error: %v", err)
		return state, nil
	}

	state.Success = "Check your email for a login link!"
	state.Email = ""
	return state, nil
}

// HandleMagicLinkVerify verifies magic link token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleMagicLinkVerify(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Delete the magic link token (one-time use)
	c.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Create session token
	sessionToken, err := c.generateToken(userToken.{{.StructName}}ID, "session", 30*24*time.Hour)
	if err != nil {
		log.Printf("Generate session token error: %v", err)
		http.Redirect(w, r, "/auth?error=login_failed", http.StatusSeeOther)
		return
	}

	// Set session cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    sessionToken,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// Redirect to home
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

{{- end }}

{{- if .EnablePasswordReset }}

type ForgotPasswordInput struct {
	Email string `json:"email" validate:"required,email"`
}

// ForgotPassword handles the "forgot_password" action to send a password reset email
func (c *{{.StructName}}Controller) ForgotPassword(state {{.StructName}}State, ctx *livetemplate.Context) ({{.StructName}}State, error) {
	var input ForgotPasswordInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		state.Error = "Email is required"
		return state, nil
	}

	// Get user
	user, err := c.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Don't reveal if email exists or not for security
		state.Success = "If that email is registered, you'll receive a password reset link shortly."
		state.Email = ""
		return state, nil
	}

	// Generate reset token
	token, err := c.generateToken(user.ID, "reset", 1*time.Hour)
	if err != nil {
		state.Error = "Failed to send reset link"
		log.Printf("Generate token error: %v", err)
		return state, nil
	}

	// Send reset email
	resetURL := fmt.Sprintf("%s/auth/reset?token=%s", c.baseURL, token)
	err = c.emailSender.Send(
		input.Email,
		"Reset your password",
		fmt.Sprintf("Click here to reset your password: %s\n\nThis link expires in 1 hour.", resetURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	state.Success = "If that email is registered, you'll receive a password reset link shortly."
	state.Email = ""
	return state, nil
}

// HandleResetPassword resets user password with token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleResetPassword(w http.ResponseWriter, r *http.Request) {
	if r.Method == "GET" {
		// Show reset form
		token := r.URL.Query().Get("token")
		if token == "" {
			http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
			return
		}

		// Verify token exists and not expired
		_, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
			Token:     token,
			ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
		})
		if err != nil {
			http.Redirect(w, r, "/auth?error=expired_token", http.StatusSeeOther)
			return
		}

		// Render reset password form (simplified - in production use proper template)
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head><title>Reset Password</title></head>
<body>
<h2>Reset Password</h2>
<form method="POST">
	<input type="hidden" name="token" value="%s">
	<label>New Password: <input type="password" name="password" required minlength="8"></label><br>
	<button type="submit">Reset Password</button>
</form>
</body>
</html>
		`, token)
		return
	}

	// Handle POST - update password
	if err := r.ParseForm(); err != nil {
		http.Redirect(w, r, "/auth?error=invalid_request", http.StatusSeeOther)
		return
	}

	token := r.FormValue("token")
	newPassword := r.FormValue("password")

	if token == "" || newPassword == "" {
		http.Redirect(w, r, "/auth?error=missing_fields", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Hash new password
	hashedPassword, err := password.Hash(newPassword)
	if err != nil {
		log.Printf("Password hash error: %v", err)
		http.Redirect(w, r, "/auth?error=password_failed", http.StatusSeeOther)
		return
	}

	// Update password
	err = c.queries.Update{{.StructName}}Password(context.Background(), models.Update{{.StructName}}PasswordParams{
		HashedPassword: hashedPassword,
		UpdatedAt:      time.Now(),
		ID:             userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Update password error: %v", err)
		http.Redirect(w, r, "/auth?error=update_failed", http.StatusSeeOther)
		return
	}

	// Delete all reset tokens for this user
	c.queries.Delete{{.StructName}}TokensByContext(context.Background(), models.Delete{{.StructName}}TokensByContextParams{
		{{.StructName}}ID: userToken.{{.StructName}}ID,
		Context:          "reset",
	})

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=password_reset", http.StatusSeeOther)
}

{{- end }}

{{- if .EnableEmailConfirm }}

// HandleConfirmEmail confirms user email with token (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleConfirmEmail(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Confirm user
	now := time.Now()
	err = c.queries.Confirm{{.StructName}}(context.Background(), models.Confirm{{.StructName}}Params{
		ConfirmedAt: sql.NullTime{Time: now, Valid: true},
		UpdatedAt:   now,
		ID:          userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Confirm user error: %v", err)
		http.Redirect(w, r, "/auth?error=confirm_failed", http.StatusSeeOther)
		return
	}

	// Delete the confirmation token
	c.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=email_confirmed", http.StatusSeeOther)
}

{{- end }}

// HandleLogout handles user logout (HTTP-only, no LiveTemplate)
func (c *{{.StructName}}Controller) HandleLogout(w http.ResponseWriter, r *http.Request) {
	// Get session token from cookie
	cookie, err := r.Cookie("{{.TableName}}_token")
	if err == nil {
		// Delete the token from database
		c.queries.Delete{{.StructName}}Token(context.Background(), cookie.Value)
	}

	// Clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    "",
		Path:     "/",
		MaxAge:   -1,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// Redirect to login
	http.Redirect(w, r, "/auth", http.StatusSeeOther)
}

// generateToken creates a random token and stores it
func (c *{{.StructName}}Controller) generateToken(userID, tokenContext string, duration time.Duration) (string, error) {
	// Generate random token
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	token := base64.URLEncoding.EncodeToString(b)

	// Store token
	tokenID := uuid.New().String()
	now := time.Now()
	expiresAt := sql.NullTime{Time: now.Add(duration), Valid: true}

	_, err := c.queries.Create{{.StructName}}Token(context.Background(), models.Create{{.StructName}}TokenParams{
		ID:        tokenID,
		{{.StructName}}ID:   userID,
		Token:     token,
		Context:   tokenContext,
		CreatedAt: now,
		ExpiresAt: expiresAt,
	})
	if err != nil {
		return "", err
	}

	return token, nil
}

// GetCurrentUser returns the authenticated user or nil
func (c *{{.StructName}}Controller) GetCurrentUser(r *http.Request) (*models.{{.StructName}}, error) {
	cookie, err := r.Cookie("{{.TableName}}_token")
	if err != nil {
		return nil, err
	}

	userToken, err := c.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     cookie.Value,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		return nil, err
	}

	user, err := c.queries.Get{{.StructName}}ByID(context.Background(), userToken.{{.StructName}}ID)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Handler creates an http.Handler for the auth LiveTemplate view
// It sets up the controller and returns a handler that can be registered with http.Handle
func Handler(queries *models.Queries) http.Handler {
	// Create controller with dependencies
	// ⚠️ IMPORTANT: Replace getEmailSender() with real email sender for production!
	controller := New{{.StructName}}Controller(queries, getEmailSender(), getBaseURL())

	// Create initial state
	initialState := New{{.StructName}}State()

	// Parse the template
	baseTmpl := livetemplate.Must(livetemplate.New("auth", livetemplate.WithDevMode(false)))
	if _, err := baseTmpl.ParseFiles("app/auth/auth.tmpl"); err != nil {
		log.Fatalf("Failed to parse auth template: %v", err)
	}

	// Return handler that serves the LiveTemplate view
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		tmpl, err := baseTmpl.Clone()
		if err != nil {
			log.Printf("Failed to clone auth template: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}
		tmpl.Handle(controller, livetemplate.AsState(initialState)).ServeHTTP(w, r)
	})
}

// getEmailSender returns the appropriate email sender based on environment
func getEmailSender() email.EmailSender {
	if os.Getenv("APP_ENV") == "production" {
		// Production: Use NoOp sender to avoid logging tokens
		// Replace this with your production email sender
		log.Printf("⚠️ WARNING: Using NoOp email sender - magic links won't be delivered!")
		return email.NewNoOpEmailSender()
	}
	// Development: Log emails to console for debugging
	return email.NewConsoleEmailSender()
}

// getBaseURL returns the base URL from environment or default
func getBaseURL() string {
	if envURL := os.Getenv("BASE_URL"); envURL != "" {
		return envURL
	}
	return "http://localhost:8080"
}

// LogoutHandler returns an http.Handler for the logout endpoint
func LogoutHandler(queries *models.Queries) http.Handler {
	controller := New{{.StructName}}Controller(queries, getEmailSender(), getBaseURL())
	return http.HandlerFunc(controller.HandleLogout)
}

{{- if .EnableMagicLink }}
// MagicLinkHandler returns an http.Handler for magic link verification
func MagicLinkHandler(queries *models.Queries) http.Handler {
	controller := New{{.StructName}}Controller(queries, getEmailSender(), getBaseURL())
	return http.HandlerFunc(controller.HandleMagicLinkVerify)
}
{{- end }}

{{- if .EnablePasswordReset }}
// ResetPasswordHandler returns an http.Handler for password reset
func ResetPasswordHandler(queries *models.Queries) http.Handler {
	controller := New{{.StructName}}Controller(queries, getEmailSender(), getBaseURL())
	return http.HandlerFunc(controller.HandleResetPassword)
}
{{- end }}

{{- if .EnableEmailConfirm }}
// ConfirmEmailHandler returns an http.Handler for email confirmation
func ConfirmEmailHandler(queries *models.Queries) http.Handler {
	controller := New{{.StructName}}Controller(queries, getEmailSender(), getBaseURL())
	return http.HandlerFunc(controller.HandleConfirmEmail)
}
{{- end }}
