package auth

// Usage: Wire this handler to your main.go
//
// Example setup in main.go:
//
//	import (
//		"{{.ModuleName}}/internal/app/auth"
//		"{{.ModuleName}}/internal/shared/email"
//	)
//
//	// Create auth state
//	emailSender := email.NewConsoleEmailSender() // or your production email sender
//	authState := auth.New{{.StructName}}State(db, emailSender, "http://localhost:8080")
//
//	// Register LiveTemplate routes
//	http.Handle("/auth", livetemplate.NewHandler(authState, "internal/app/auth/auth.tmpl"))
//
//	// Register HTTP-only routes (no LiveTemplate)
//	http.HandleFunc("/auth/logout", authState.HandleLogout)
{{- if .EnableMagicLink }}
//	http.HandleFunc("/auth/magic", authState.HandleMagicLinkVerify)
{{- end }}
{{- if .EnablePasswordReset }}
//	http.HandleFunc("/auth/reset", authState.HandleResetPassword)
{{- end }}
{{- if .EnableEmailConfirm }}
//	http.HandleFunc("/auth/confirm", authState.HandleConfirmEmail)
{{- end }}
//
// For protected routes, use GetCurrentUser:
//
//	func protectedHandler(w http.ResponseWriter, r *http.Request) {
//		user, err := authState.GetCurrentUser(r)
//		if err != nil {
//			http.Redirect(w, r, "/auth", http.StatusSeeOther)
//			return
//		}
//		// ... user is authenticated
//	}

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"time"

	"{{.ModuleName}}/internal/database/models"
	"{{.ModuleName}}/internal/shared/email"
	{{- if .EnablePassword }}
	"{{.ModuleName}}/internal/shared/password"
	{{- end }}
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/livetemplate/livetemplate"
)

var validate = validator.New()

type {{.StructName}}State struct {
	db             *sql.DB
	queries        *models.Queries
	emailSender    email.EmailSender
	baseURL        string

	// Page state
	View           string `json:"view"` // "login", "register", "forgot", "reset", "confirm"
	Email          string `json:"email"`
	Password       string `json:"password"`
	Error          string `json:"error"`
	Success        string `json:"success"`
	Token          string `json:"token"`
	ShowMagicLink  bool   `json:"show_magic_link"`
	ShowPassword   bool   `json:"show_password"`
}

func New{{.StructName}}State(db *sql.DB, emailSender email.EmailSender, baseURL string) *{{.StructName}}State {
	return &{{.StructName}}State{
		db:             db,
		queries:        models.New(db),
		emailSender:    emailSender,
		baseURL:        baseURL,
		View:           "login",
		ShowMagicLink:  {{.EnableMagicLink}},
		ShowPassword:   {{.EnablePassword}},
	}
}

// Change implements the Store interface
func (s *{{.StructName}}State) Change(ctx *livetemplate.ActionContext) error {
	switch ctx.Action {
	{{- if .EnablePassword }}
	case "register":
		return s.handleRegister(ctx)
	case "login":
		return s.handleLogin(ctx)
	{{- end }}
	{{- if .EnableMagicLink }}
	case "magic-link":
		return s.handleMagicLink(ctx)
	{{- end }}
	{{- if .EnablePasswordReset }}
	case "forgot-password":
		return s.handleForgotPassword(ctx)
	{{- end }}
	case "switch-view":
		// Switch between login/register/forgot views
		view := ctx.GetString("view")
		if view != "" {
			s.View = view
			s.Error = ""
			s.Success = ""
		}
		return nil
	default:
		return fmt.Errorf("unknown action: %s", ctx.Action)
	}
}

{{- if .EnablePassword }}

type RegisterInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8"`
}

// handleRegister handles user registration
func (s *{{.StructName}}State) handleRegister(ctx *livetemplate.ActionContext) error {
	var input RegisterInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		s.Error = "Email and password are required"
		return nil
	}

	// Check if user already exists
	existing, err := s.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err == nil && existing.ID != "" {
		s.Error = "Email already registered"
		return nil
	}

	// Hash password
	hashedPassword, err := password.Hash(input.Password)
	if err != nil {
		s.Error = "Failed to process password"
		log.Printf("Password hash error: %v", err)
		return nil
	}

	// Create user
	userID := uuid.New().String()
	now := time.Now()

	_, err = s.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
		ID:             userID,
		Email:          input.Email,
		HashedPassword: hashedPassword,
		CreatedAt:      now,
		UpdatedAt:      now,
	})
	if err != nil {
		s.Error = "Failed to create account"
		log.Printf("Create user error: %v", err)
		return nil
	}

	{{- if .EnableEmailConfirm }}
	// Send confirmation email
	token, err := s.generateToken(userID, "confirm", 24*time.Hour)
	if err != nil {
		s.Error = "Account created but failed to send confirmation email"
		log.Printf("Generate token error: %v", err)
		return nil
	}

	confirmURL := fmt.Sprintf("%s/auth/confirm?token=%s", s.baseURL, token)
	err = s.emailSender.Send(
		input.Email,
		"Confirm your email",
		fmt.Sprintf("Click here to confirm your email: %s", confirmURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	s.Success = "Account created! Please check your email to confirm your account."
	{{- else }}
	s.Success = "Account created! You can now log in."
	{{- end }}

	s.View = "login"
	s.Email = ""
	s.Password = ""
	s.Error = ""

	return nil
}

type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

// handleLogin handles password-based login
func (s *{{.StructName}}State) handleLogin(ctx *livetemplate.ActionContext) error {
	var input LoginInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		s.Error = "Email and password are required"
		return nil
	}

	// Get user
	user, err := s.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		s.Error = "Invalid email or password"
		return nil
	}

	{{- if .EnableEmailConfirm }}
	// Check if email is confirmed
	if !user.ConfirmedAt.Valid {
		s.Error = "Please confirm your email before logging in"
		return nil
	}
	{{- end }}

	// Verify password
	if !password.Verify(input.Password, user.HashedPassword) {
		s.Error = "Invalid email or password"
		return nil
	}

	// Create session token
	token, err := s.generateToken(user.ID, "session", 30*24*time.Hour) // 30 days
	if err != nil {
		s.Error = "Login failed"
		log.Printf("Generate session token error: %v", err)
		return nil
	}

	// Set session cookie using v0.5.1 ActionContext API
	if err := ctx.SetCookie(&http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    token,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60, // 30 days
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	}); err != nil {
		s.Error = "Login failed"
		log.Printf("Set cookie error: %v", err)
		return nil
	}

	// Redirect to home using v0.5.1 ActionContext API
	if err := ctx.Redirect("/", http.StatusSeeOther); err != nil {
		s.Error = "Login failed"
		log.Printf("Redirect error: %v", err)
		return nil
	}

	return nil
}

{{- end }}

{{- if .EnableMagicLink }}

type MagicLinkInput struct {
	Email string `json:"email" validate:"required,email"`
}

// handleMagicLink sends a magic link email
func (s *{{.StructName}}State) handleMagicLink(ctx *livetemplate.ActionContext) error {
	var input MagicLinkInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		s.Error = "Email is required"
		return nil
	}

	// Get or create user
	user, err := s.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Create new user
		userID := uuid.New().String()
		now := time.Now()
		user, err = s.queries.Create{{.StructName}}(context.Background(), models.Create{{.StructName}}Params{
			ID:        userID,
			Email:     input.Email,
			{{- if .EnablePassword }}
			HashedPassword: "", // No password for magic-link only users
			{{- end }}
			CreatedAt: now,
			UpdatedAt: now,
		})
		if err != nil {
			s.Error = "Failed to process request"
			log.Printf("Create user error: %v", err)
			return nil
		}
	}

	// Generate magic link token
	token, err := s.generateToken(user.ID, "magic", 15*time.Minute)
	if err != nil {
		s.Error = "Failed to send magic link"
		log.Printf("Generate token error: %v", err)
		return nil
	}

	// Send magic link email
	magicURL := fmt.Sprintf("%s/auth/magic?token=%s", s.baseURL, token)
	err = s.emailSender.Send(
		input.Email,
		"Your login link",
		fmt.Sprintf("Click here to log in: %s\n\nThis link expires in 15 minutes.", magicURL),
	)
	if err != nil {
		s.Error = "Failed to send magic link"
		log.Printf("Send email error: %v", err)
		return nil
	}

	s.Success = "Check your email for a login link!"
	s.Email = ""
	return nil
}

// HandleMagicLinkVerify verifies magic link token (HTTP-only, no LiveTemplate)
func (s *{{.StructName}}State) HandleMagicLinkVerify(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := s.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Delete the magic link token (one-time use)
	s.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Create session token
	sessionToken, err := s.generateToken(userToken.{{.StructName}}ID, "session", 30*24*time.Hour)
	if err != nil {
		log.Printf("Generate session token error: %v", err)
		http.Redirect(w, r, "/auth?error=login_failed", http.StatusSeeOther)
		return
	}

	// Set session cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    sessionToken,
		Path:     "/",
		MaxAge:   30 * 24 * 60 * 60,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// Redirect to home
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

{{- end }}

{{- if .EnablePasswordReset }}

type ForgotPasswordInput struct {
	Email string `json:"email" validate:"required,email"`
}

// handleForgotPassword sends a password reset email
func (s *{{.StructName}}State) handleForgotPassword(ctx *livetemplate.ActionContext) error {
	var input ForgotPasswordInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		s.Error = "Email is required"
		return nil
	}

	// Get user
	user, err := s.queries.Get{{.StructName}}ByEmail(context.Background(), input.Email)
	if err != nil {
		// Don't reveal if email exists or not for security
		s.Success = "If that email is registered, you'll receive a password reset link shortly."
		s.Email = ""
		return nil
	}

	// Generate reset token
	token, err := s.generateToken(user.ID, "reset", 1*time.Hour)
	if err != nil {
		s.Error = "Failed to send reset link"
		log.Printf("Generate token error: %v", err)
		return nil
	}

	// Send reset email
	resetURL := fmt.Sprintf("%s/auth/reset?token=%s", s.baseURL, token)
	err = s.emailSender.Send(
		input.Email,
		"Reset your password",
		fmt.Sprintf("Click here to reset your password: %s\n\nThis link expires in 1 hour.", resetURL),
	)
	if err != nil {
		log.Printf("Send email error: %v", err)
	}

	s.Success = "If that email is registered, you'll receive a password reset link shortly."
	s.Email = ""
	return nil
}

// HandleResetPassword resets user password with token (HTTP-only, no LiveTemplate)
func (s *{{.StructName}}State) HandleResetPassword(w http.ResponseWriter, r *http.Request) {
	if r.Method == "GET" {
		// Show reset form
		token := r.URL.Query().Get("token")
		if token == "" {
			http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
			return
		}

		// Verify token exists and not expired
		_, err := s.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
			Token:     token,
			ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
		})
		if err != nil {
			http.Redirect(w, r, "/auth?error=expired_token", http.StatusSeeOther)
			return
		}

		// Render reset password form (simplified - in production use proper template)
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head><title>Reset Password</title></head>
<body>
<h2>Reset Password</h2>
<form method="POST">
	<input type="hidden" name="token" value="%s">
	<label>New Password: <input type="password" name="password" required minlength="8"></label><br>
	<button type="submit">Reset Password</button>
</form>
</body>
</html>
		`, token)
		return
	}

	// Handle POST - update password
	if err := r.ParseForm(); err != nil {
		http.Redirect(w, r, "/auth?error=invalid_request", http.StatusSeeOther)
		return
	}

	token := r.FormValue("token")
	newPassword := r.FormValue("password")

	if token == "" || newPassword == "" {
		http.Redirect(w, r, "/auth?error=missing_fields", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := s.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Hash new password
	hashedPassword, err := password.Hash(newPassword)
	if err != nil {
		log.Printf("Password hash error: %v", err)
		http.Redirect(w, r, "/auth?error=password_failed", http.StatusSeeOther)
		return
	}

	// Update password
	err = s.queries.Update{{.StructName}}Password(context.Background(), models.Update{{.StructName}}PasswordParams{
		HashedPassword: hashedPassword,
		UpdatedAt:      time.Now(),
		ID:             userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Update password error: %v", err)
		http.Redirect(w, r, "/auth?error=update_failed", http.StatusSeeOther)
		return
	}

	// Delete all reset tokens for this user
	s.queries.Delete{{.StructName}}TokensByContext(context.Background(), models.Delete{{.StructName}}TokensByContextParams{
		{{.StructName}}ID: userToken.{{.StructName}}ID,
		Context:          "reset",
	})

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=password_reset", http.StatusSeeOther)
}

{{- end }}

{{- if .EnableEmailConfirm }}

// HandleConfirmEmail confirms user email with token (HTTP-only, no LiveTemplate)
func (s *{{.StructName}}State) HandleConfirmEmail(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Verify token
	userToken, err := s.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     token,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		http.Redirect(w, r, "/auth?error=invalid_token", http.StatusSeeOther)
		return
	}

	// Confirm user
	now := time.Now()
	err = s.queries.Confirm{{.StructName}}(context.Background(), models.Confirm{{.StructName}}Params{
		ConfirmedAt: sql.NullTime{Time: now, Valid: true},
		UpdatedAt:   now,
		ID:          userToken.{{.StructName}}ID,
	})
	if err != nil {
		log.Printf("Confirm user error: %v", err)
		http.Redirect(w, r, "/auth?error=confirm_failed", http.StatusSeeOther)
		return
	}

	// Delete the confirmation token
	s.queries.Delete{{.StructName}}Token(context.Background(), token)

	// Redirect to login with success
	http.Redirect(w, r, "/auth?success=email_confirmed", http.StatusSeeOther)
}

{{- end }}

// HandleLogout handles user logout (HTTP-only, no LiveTemplate)
func (s *{{.StructName}}State) HandleLogout(w http.ResponseWriter, r *http.Request) {
	// Get session token from cookie
	cookie, err := r.Cookie("{{.TableName}}_token")
	if err == nil {
		// Delete the token from database
		s.queries.Delete{{.StructName}}Token(context.Background(), cookie.Value)
	}

	// Clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "{{.TableName}}_token",
		Value:    "",
		Path:     "/",
		MaxAge:   -1,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// Redirect to login
	http.Redirect(w, r, "/auth", http.StatusSeeOther)
}

// generateToken creates a random token and stores it
func (s *{{.StructName}}State) generateToken(userID, context string, duration time.Duration) (string, error) {
	// Generate random token
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	token := base64.URLEncoding.EncodeToString(b)

	// Store token
	tokenID := uuid.New().String()
	now := time.Now()
	expiresAt := sql.NullTime{Time: now.Add(duration), Valid: true}

	_, err := s.queries.Create{{.StructName}}Token(context.Background(), models.Create{{.StructName}}TokenParams{
		ID:        tokenID,
		{{.StructName}}ID:   userID,
		Token:     token,
		Context:   context,
		CreatedAt: now,
		ExpiresAt: expiresAt,
	})
	if err != nil {
		return "", err
	}

	return token, nil
}

// GetCurrentUser returns the authenticated user or nil
func (s *{{.StructName}}State) GetCurrentUser(r *http.Request) (*models.{{.StructName}}, error) {
	cookie, err := r.Cookie("{{.TableName}}_token")
	if err != nil {
		return nil, err
	}

	userToken, err := s.queries.Get{{.StructName}}Token(context.Background(), models.Get{{.StructName}}TokenParams{
		Token:     cookie.Value,
		ExpiresAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if err != nil {
		return nil, err
	}

	user, err := s.queries.Get{{.StructName}}ByID(context.Background(), userToken.{{.StructName}}ID)
	if err != nil {
		return nil, err
	}

	return &user, nil
}
