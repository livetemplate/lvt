package main

import (
	"bufio"
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"[[.ModuleName]]/internal/app/home"
	"[[.ModuleName]]/internal/database"
)

func main() {
	// Set up structured logging
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: getLogLevel(),
	}))
	slog.SetDefault(logger)

	slog.Info("[[.AppName]] starting...",
		"environment", os.Getenv("APP_ENV"),
		"port", getPort())

	// Initialize database
	dbPath := getDBPath()
	_, err := database.InitDB(dbPath)
	if err != nil {
		slog.Error("Failed to initialize database", "error", err)
		os.Exit(1)
	}
	defer database.CloseDB()

	// Register routes on the default mux (http.DefaultServeMux)
	// Note: Resource/view routes are added via code generation using http.Handle()

	// Health check endpoint
	http.HandleFunc("/health", healthCheckHandler)

	// Home page
	http.Handle("/", home.Handler())

	// Serve LiveTemplate client library
	http.HandleFunc("/livetemplate-client.js", serveClientLibrary)

	// TODO: Add routes here (added automatically by `lvt gen`)
	// Example: http.Handle("/users", users.Handler(queries))

	// Wrap the default mux with middleware
	handler := securityHeadersMiddleware(
		recoveryMiddleware(
			loggingMiddleware(http.DefaultServeMux)))

	// Create server with production-ready settings
	srv := &http.Server{
		Addr:         ":" + getPort(),
		Handler:      handler,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server in goroutine
	go func() {
		slog.Info("Server listening", "address", srv.Addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("Server error", "error", err)
			os.Exit(1)
		}
	}()

	// Graceful shutdown on signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	slog.Info("Shutting down server...")

	// Give outstanding requests time to complete
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		slog.Error("Server forced to shutdown", "error", err)
		os.Exit(1)
	}

	slog.Info("Server exited cleanly")
}

// healthCheckHandler returns 200 OK if the server is running
func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status":"ok"}`))
}

// getPort returns the port from PORT env var, defaulting to 8080
func getPort() string {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	return port
}

// getLogLevel returns the log level from LOG_LEVEL env var
func getLogLevel() slog.Level {
	level := os.Getenv("LOG_LEVEL")
	switch level {
	case "debug":
		return slog.LevelDebug
	case "info":
		return slog.LevelInfo
	case "warn":
		return slog.LevelWarn
	case "error":
		return slog.LevelError
	default:
		return slog.LevelInfo
	}
}

// getDBPath returns database path, using :memory: in test mode
func getDBPath() string {
	if os.Getenv("TEST_MODE") == "1" {
		return ":memory:"
	}
	// Use DATABASE_PATH env var if set, otherwise default
	path := os.Getenv("DATABASE_PATH")
	if path == "" {
		path = "app.db"
	}
	return path
}

// loggingMiddleware logs all HTTP requests with structured logging
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Create a response writer wrapper to capture status code
		rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		next.ServeHTTP(rw, r)

		duration := time.Since(start)

		slog.Info("HTTP request",
			"method", r.Method,
			"path", r.URL.Path,
			"status", rw.statusCode,
			"duration_ms", duration.Milliseconds(),
			"remote_addr", r.RemoteAddr,
			"user_agent", r.UserAgent())
	})
}

// responseWriter wraps http.ResponseWriter to capture the status code
// and implements http.Hijacker for WebSocket support
type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

// Hijack implements http.Hijacker to support WebSocket upgrades
func (rw *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	hijacker, ok := rw.ResponseWriter.(http.Hijacker)
	if !ok {
		return nil, nil, fmt.Errorf("responseWriter does not implement http.Hijacker")
	}
	return hijacker.Hijack()
}

// recoveryMiddleware recovers from panics and logs them
func recoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				slog.Error("Panic recovered",
					"error", err,
					"method", r.Method,
					"path", r.URL.Path,
					"remote_addr", r.RemoteAddr)

				// Return 500 error
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			}
		}()
		next.ServeHTTP(w, r)
	})
}

// securityHeadersMiddleware adds security headers to all responses
func securityHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Prevent MIME type sniffing
		w.Header().Set("X-Content-Type-Options", "nosniff")

		// Enable XSS protection
		w.Header().Set("X-XSS-Protection", "1; mode=block")

		// Prevent clickjacking
		w.Header().Set("X-Frame-Options", "DENY")

		// Force HTTPS in production
		if os.Getenv("APP_ENV") == "production" {
			w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}

		// Content Security Policy (adjust as needed)
		// This is a basic CSP - customize based on your needs
		w.Header().Set("Content-Security-Policy",
			"default-src 'self'; "+
				"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net; "+
				"style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; "+
				"img-src 'self' data: https:; "+
				"font-src 'self' data: https://cdn.jsdelivr.net;")

		next.ServeHTTP(w, r)
	})
}

// serveClientLibrary serves the LiveTemplate client JavaScript library
func serveClientLibrary(w http.ResponseWriter, r *http.Request) {
	// Try multiple paths for the client library (development/testing)
	paths := []string{
		"livetemplate-client.js",                                  // Local copy (for testing)
		"../../client/dist/livetemplate-client.browser.js",        // When running from cmd/app
		"../../../client/dist/livetemplate-client.browser.js",     // When running from deeper
		"../../../../client/dist/livetemplate-client.browser.js",  // When running even deeper
	}

	for _, path := range paths {
		content, err := os.ReadFile(path)
		if err == nil {
			w.Header().Set("Content-Type", "application/javascript")
			w.Header().Set("Cache-Control", "public, max-age=31536000") // Cache for 1 year
			w.Write(content)
			return
		}
	}

	// If not found locally, return error with CDN suggestion
	slog.Warn("Client library not found locally", "path", r.URL.Path)
	http.Error(w, "Client library not found. For production, use CDN: https://cdn.jsdelivr.net/npm/@livetemplate/client/dist/livetemplate-client.browser.js", http.StatusNotFound)
}
