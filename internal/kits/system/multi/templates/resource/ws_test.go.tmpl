package [[.PackageName]]

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os/exec"
	"strings"
	"testing"
	"time"

	"github.com/gorilla/websocket"
	e2etest "github.com/livetemplate/livetemplate/cmd/lvt/testing"
)

func TestWebSocketBasic(t *testing.T) {
	// Get a free port
	port, err := e2etest.GetFreePort()
	if err != nil {
		t.Fatalf("Failed to get free port: %v", err)
	}

	portStr := fmt.Sprintf("%d", port)
	serverURL := fmt.Sprintf("http://localhost:%s", portStr)
	wsURL := fmt.Sprintf("ws://localhost:%s/[[.ResourceNameLower]]", portStr)

	// Start server on dynamic port
	cmd := exec.Command("go", "run", "../../cmd/[[.ModuleName]]/main.go", "../../internal/database/db.go")
	cmd.Env = append([]string{"PORT=" + portStr, "TEST_MODE=1"}, cmd.Environ()...)

	serverLogs := &bytes.Buffer{}
	cmd.Stdout = serverLogs
	cmd.Stderr = serverLogs

	if err := cmd.Start(); err != nil {
		t.Fatalf("Failed to start server: %v", err)
	}
	defer func() {
		if cmd.Process != nil {
			cmd.Process.Kill()
			// Wait for process to exit to avoid zombie processes and I/O wait issues
			cmd.Wait()
		}
		t.Logf("=== SERVER LOGS ===\n%s", serverLogs.String())
	}()

	// Wait for server
	time.Sleep(2 * time.Second)
	for i := 0; i < 30; i++ {
		if resp, err := http.Get(serverURL); err == nil {
			resp.Body.Close()
			break
		}
		time.Sleep(100 * time.Millisecond)
	}

	t.Log("Server is up, trying to connect WebSocket...")

	// Try to connect
	dialer := websocket.Dialer{}
	conn, resp, err := dialer.Dial(wsURL, nil)
	if err != nil {
		t.Fatalf("Failed to connect: %v, response: %v", err, resp)
	}
	defer conn.Close()

	t.Log("WebSocket connected successfully!")

	// Read first message (initial tree)
	_, msg, err := conn.ReadMessage()
	if err != nil {
		t.Fatalf("Failed to read message: %v", err)
	}

	t.Logf("Received initial message, length: %d bytes", len(msg))
	t.Logf("Initial message: %s", string(msg))

	// Verify initial state
	if !strings.Contains(string(msg), "[[.ResourceName]] Management") {
		t.Error("Initial message should contain '[[.ResourceName]] Management'")
	}

	// Send add action
	t.Log("Sending add [[.ResourceNameLower]] action...")
	addAction := map[string]interface{}{
		"action": "add",
		"data": map[string]interface{}{
[[- range .Fields]]
[[- if eq .GoType "string"]]
			"[[.Name]]": "Test [[.Name | title]]",
[[- else if eq .GoType "int64"]]
			"[[.Name]]": 42,
[[- else if eq .GoType "bool"]]
			"[[.Name]]": true,
[[- else if eq .GoType "float64"]]
			"[[.Name]]": 3.14,
[[- end]]
[[- end]]
		},
	}
	addJSON, _ := json.Marshal(addAction)

	if err := conn.WriteMessage(websocket.TextMessage, addJSON); err != nil {
		t.Fatalf("Failed to send add action: %v", err)
	}

	// Read add response with timeout
	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	_, msg, err = conn.ReadMessage()
	if err != nil {
		time.Sleep(500 * time.Millisecond)
		t.Fatalf("Failed to read add response: %v\nServer logs:\n%s", err, serverLogs.String())
	}

	t.Logf("Received add response, length: %d bytes", len(msg))
	t.Logf("Response: %s", msg)

	// Verify the response contains the [[.ResourceNameLower]]
[[- range .Fields]]
[[- if eq .GoType "string"]]
	if !strings.Contains(string(msg), "Test [[.Name | title]]") {
		t.Error("Add response should contain the new [[$.ResourceNameLower]] [[.Name]]")
	}
[[- end]]
[[- end]]

	// Extract [[.ResourceNameLower]] ID from response for delete test
	var [[.ResourceNameLower]]ID string
	msgStr := string(msg)
	if idx := strings.Index(msgStr, `data-key="`); idx != -1 {
		start := idx + len(`data-key="`)
		end := strings.Index(msgStr[start:], `"`)
		if end != -1 {
			[[.ResourceNameLower]]ID = msgStr[start : start+end]
			t.Logf("Extracted [[.ResourceNameLower]] ID: %s", [[.ResourceNameLower]]ID)
		}
	}

	if [[.ResourceNameLower]]ID != "" {
		// Send delete action
		t.Log("Sending delete action...")
		deleteAction := map[string]interface{}{
			"action": "delete",
			"data": map[string]interface{}{
				"id": [[.ResourceNameLower]]ID,
			},
		}
		deleteJSON, _ := json.Marshal(deleteAction)

		if err := conn.WriteMessage(websocket.TextMessage, deleteJSON); err != nil {
			t.Fatalf("Failed to send delete action: %v", err)
		}

		// Read delete response
		conn.SetReadDeadline(time.Now().Add(5 * time.Second))
		_, msg, err = conn.ReadMessage()
		if err != nil {
			t.Fatalf("Failed to read delete response: %v", err)
		}

		t.Logf("Received delete response: %s", msg)
	}

	t.Log("âœ… WebSocket test passed!")
}
