package [[.PackageName]]

import (
	"context"
	"fmt"
	"log"
	"math"
	"net/http"
	"sort"
	"strings"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/livetemplate/livetemplate"
	"[[.ModuleName]]/database/models"
)

var validate = validator.New()

type [[.ResourceName]]Item = models.[[.ResourceNameSingular]]

type AddInput struct {
[[- range .Fields]]
[[- if eq .GoType "bool"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]"`
[[- else if eq .GoType "string"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required,min=3"`
[[- else]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required"`
[[- end]]
[[- end]]
}

type UpdateInput struct {
	ID string `json:"id" validate:"required"`
[[- range .Fields]]
[[- if eq .GoType "bool"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]"`
[[- else if eq .GoType "string"]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required,min=3"`
[[- else]]
	[[.Name | camelCase]] [[.GoType]] `json:"[[.Name]]" validate:"required"`
[[- end]]
[[- end]]
}

type DeleteInput struct {
	ID string `json:"id" validate:"required"`
}

type SearchInput struct {
	Query string `json:"query"`
}

type SortInput struct {
	SortBy string `json:"sort_by"`
}

type PaginationInput struct {
	Page int `json:"page" validate:"required,min=1"`
}

// [[.ResourceName]]Controller is a singleton that holds dependencies (DB, logger, etc.)
type [[.ResourceName]]Controller struct {
	Queries *models.Queries
}

// [[.ResourceName]]State is pure data, cloned per session
type [[.ResourceName]]State struct {
	Title        string                `json:"title"`
	SearchQuery  string                `json:"search_query"`
	SortBy       string                `json:"sort_by"`
	Filtered[[.ResourceNamePlural]]  [][[.ResourceName]]Item `json:"filtered_[[.ResourceNameLower]]s"`
	CurrentPage  int                   `json:"current_page"`
	PageSize     int                   `json:"page_size"`
	TotalPages   int                   `json:"total_pages"`
	Paginated[[.ResourceNamePlural]] [][[.ResourceName]]Item `json:"paginated_[[.ResourceNameLower]]s"`
	TotalCount   int                   `json:"total_count"`
	LastUpdated  string                `json:"last_updated"`
	EditingID    string                `json:"editing_id"`
	Editing[[.ResourceName]] *[[.ResourceName]]Item   `json:"editing_[[.ResourceNameLower]]"`
	IsEditingMode bool                 `json:"is_editing_mode"` // For page mode: true when at /resource/:id/edit
	PaginationMode string              `json:"pagination_mode"` // "infinite", "load-more", "prev-next", "numbers"
	LoadedCount    int                 `json:"loaded_count"`    // For infinite/load-more modes
	HasMore        bool                `json:"has_more"`        // Whether more items available
	IsLoading      bool                `json:"is_loading"`      // Loading indicator
	CSSFramework   string              `json:"-"`               // CSS framework for templates
}

// Add handles the "add" action to create a new resource
func (c *[[.ResourceName]]Controller) Add(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input AddInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	log.Printf("[lvt debug] add input: %+v", input)

	now := time.Now()
	id := fmt.Sprintf("[[.ResourceNameLower]]-%d", now.UnixNano())

	_, err := c.Queries.Create[[.ResourceNameSingular]](dbCtx, models.Create[[.ResourceNameSingular]]Params{
		ID:        id,
[[- range .Fields]]
		[[.Name | camelCase]]: input.[[.Name | camelCase]],
[[- end]]
		CreatedAt: now,
	})
	if err != nil {
		return state, fmt.Errorf("failed to create [[.ResourceNameLower]]: %w", err)
	}

	state, err = c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Edit handles the "edit" action to start editing a resource
func (c *[[.ResourceName]]Controller) Edit(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	// Find the item to edit
	[[.ResourceNameLower]]s, err := c.Queries.GetAll[[.ResourceNamePlural]](dbCtx)
	if err != nil {
		return state, fmt.Errorf("failed to load [[.ResourceNameLower]]s: %w", err)
	}

	for _, item := range [[.ResourceNameLower]]s {
		if item.ID == input.ID {
			state.EditingID = input.ID
			itemCopy := item
			state.Editing[[.ResourceName]] = &itemCopy
			break
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Update handles the "update" action to save changes to a resource
func (c *[[.ResourceName]]Controller) Update(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input UpdateInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	err := c.Queries.Update[[.ResourceNameSingular]](dbCtx, models.Update[[.ResourceNameSingular]]Params{
		ID: input.ID,
[[- range .Fields]]
		[[.Name | camelCase]]: input.[[.Name | camelCase]],
[[- end]]
	})
	if err != nil {
		return state, fmt.Errorf("failed to update [[.ResourceNameLower]]: %w", err)
	}

	// For page mode: Exit edit mode and stay on detail view
	state.IsEditingMode = false

	// Reload the updated resource
	state, err = c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	// Close modal / clear editing state after successful save
	state.EditingID = ""
	state.Editing[[.ResourceName]] = nil

	state.LastUpdated = formatTime()
	return state, nil
}

// CancelEdit handles the "cancel_edit" action to cancel editing
func (c *[[.ResourceName]]Controller) CancelEdit(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	state.EditingID = ""
	state.Editing[[.ResourceName]] = nil
	state.LastUpdated = formatTime()
	return state, nil
}

// View handles the "view" action to view a resource
func (c *[[.ResourceName]]Controller) View(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	// Find the item to view/edit
	[[.ResourceNameLower]]s, err := c.Queries.GetAll[[.ResourceNamePlural]](dbCtx)
	if err != nil {
		return state, fmt.Errorf("failed to load [[.ResourceNameLower]]s: %w", err)
	}

	for _, item := range [[.ResourceNameLower]]s {
		if item.ID == input.ID {
			state.EditingID = input.ID
			itemCopy := item
			state.Editing[[.ResourceName]] = &itemCopy
			break
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Back handles the "back" action to return to list view
func (c *[[.ResourceName]]Controller) Back(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	state.EditingID = ""
	state.Editing[[.ResourceName]] = nil
	state.LastUpdated = formatTime()
	return state, nil
}

// Delete handles the "delete" action to remove a resource
func (c *[[.ResourceName]]Controller) Delete(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	err := c.Queries.Delete[[.ResourceNameSingular]](dbCtx, input.ID)
	if err != nil {
		return state, fmt.Errorf("failed to delete [[.ResourceNameLower]]: %w", err)
	}

	// Clear editing state (for page mode)
	state.EditingID = ""
	state.Editing[[.ResourceName]] = nil

	state, err = c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Search handles the "search" action to filter resources
func (c *[[.ResourceName]]Controller) Search(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input SearchInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}
	state.SearchQuery = input.Query
	// Reset infinite scroll when searching
	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		state.LoadedCount = state.PageSize
	}

	state, err := c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Sort handles the "sort" action to sort resources
func (c *[[.ResourceName]]Controller) Sort(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input SortInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}
	state.SortBy = input.SortBy
	// Reset infinite scroll when sorting
	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		state.LoadedCount = state.PageSize
	}

	state, err := c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// NextPage handles the "next_page" action for pagination
func (c *[[.ResourceName]]Controller) NextPage(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	if state.CurrentPage < state.TotalPages {
		state.CurrentPage++
	}
	state, err := c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// PrevPage handles the "prev_page" action for pagination
func (c *[[.ResourceName]]Controller) PrevPage(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	if state.CurrentPage > 1 {
		state.CurrentPage--
	}
	state, err := c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// GotoPage handles the "goto_page" action to jump to a specific page
func (c *[[.ResourceName]]Controller) GotoPage(state [[.ResourceName]]State, ctx *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	var input PaginationInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}
	if input.Page >= 1 && input.Page <= state.TotalPages {
		state.CurrentPage = input.Page
	}
	state, err := c.load[[.ResourceName]]s(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// LoadMore handles the "load_more" action for infinite scroll
func (c *[[.ResourceName]]Controller) LoadMore(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	dbCtx := context.Background()

	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		if state.HasMore && !state.IsLoading {
			state.IsLoading = true
			state.LoadedCount += state.PageSize
			var err error
			state, err = c.load[[.ResourceName]]s(state, dbCtx)
			if err != nil {
				return state, err
			}
			state.IsLoading = false
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Mount is called once when a new session is created
func (c *[[.ResourceName]]Controller) Mount(state [[.ResourceName]]State, _ *livetemplate.Context) ([[.ResourceName]]State, error) {
	return c.load[[.ResourceName]]s(state, context.Background())
}

func (c *[[.ResourceName]]Controller) load[[.ResourceName]]s(state [[.ResourceName]]State, ctx context.Context) ([[.ResourceName]]State, error) {
	[[.ResourceNameLower]]s, err := c.Queries.GetAll[[.ResourceNamePlural]](ctx)
	if err != nil {
		return state, fmt.Errorf("failed to load [[.ResourceNameLower]]s: %w", err)
	}

	if state.SearchQuery == "" {
		state.Filtered[[.ResourceNamePlural]] = [[.ResourceNameLower]]s
	} else {
		state.Filtered[[.ResourceNamePlural]] = [][[.ResourceName]]Item{}
		query := strings.ToLower(state.SearchQuery)
		for _, item := range [[.ResourceNameLower]]s {
			// Search across all text fields
[[- range .Fields]]
[[- if eq .GoType "string"]]
			if strings.Contains(strings.ToLower(item.[[.Name | camelCase]]), query) {
				state.Filtered[[$.ResourceNamePlural]] = append(state.Filtered[[$.ResourceNamePlural]], item)
				continue
			}
[[- end]]
[[- end]]
		}
	}

	state.TotalCount = len([[.ResourceNameLower]]s)
	state = applySorting(state)
	state = applyPagination(state)

	return state, nil
}

// applySorting sorts the filtered items in-place based on the SortBy field.
// Note: sort.Slice mutates the slice in place. This is safe because:
// 1. State is cloned per session via AsState (JSON serialization creates fresh slices)
// 2. The slice is populated fresh from the database in each load operation
// 3. State is passed by value and returned, not shared across sessions
func applySorting(state [[.ResourceName]]State) [[.ResourceName]]State {
	switch state.SortBy {
[[- range .Fields]]
[[- if eq .GoType "string"]]
	case "[[.Name]]_asc":
		sort.Slice(state.Filtered[[$.ResourceNamePlural]], func(i, j int) bool {
			return strings.ToLower(state.Filtered[[$.ResourceNamePlural]][i].[[.Name | camelCase]]) < strings.ToLower(state.Filtered[[$.ResourceNamePlural]][j].[[.Name | camelCase]])
		})
	case "[[.Name]]_desc":
		sort.Slice(state.Filtered[[$.ResourceNamePlural]], func(i, j int) bool {
			return strings.ToLower(state.Filtered[[$.ResourceNamePlural]][i].[[.Name | camelCase]]) > strings.ToLower(state.Filtered[[$.ResourceNamePlural]][j].[[.Name | camelCase]])
		})
[[- end]]
[[- end]]
	case "oldest_first":
		sort.Slice(state.Filtered[[.ResourceNamePlural]], func(i, j int) bool {
			return state.Filtered[[.ResourceNamePlural]][i].CreatedAt.Before(state.Filtered[[.ResourceNamePlural]][j].CreatedAt)
		})
	default:
		sort.Slice(state.Filtered[[.ResourceNamePlural]], func(i, j int) bool {
			return state.Filtered[[.ResourceNamePlural]][i].CreatedAt.After(state.Filtered[[.ResourceNamePlural]][j].CreatedAt)
		})
	}
	return state
}

func applyPagination(state [[.ResourceName]]State) [[.ResourceName]]State {
	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		return applyInfiniteScroll(state)
	}
	return applyPagedNavigation(state)
}

func applyInfiniteScroll(state [[.ResourceName]]State) [[.ResourceName]]State {
	// Initialize LoadedCount if not set
	if state.LoadedCount == 0 {
		state.LoadedCount = state.PageSize
	}

	if len(state.Filtered[[.ResourceNamePlural]]) == 0 {
		state.Paginated[[.ResourceNamePlural]] = [][[.ResourceName]]Item{}
		state.HasMore = false
		return state
	}

	// Load items from 0 to LoadedCount
	end := state.LoadedCount
	if end > len(state.Filtered[[.ResourceNamePlural]]) {
		end = len(state.Filtered[[.ResourceNamePlural]])
	}

	state.Paginated[[.ResourceNamePlural]] = state.Filtered[[.ResourceNamePlural]][0:end]
	state.HasMore = end < len(state.Filtered[[.ResourceNamePlural]])
	return state
}

func applyPagedNavigation(state [[.ResourceName]]State) [[.ResourceName]]State {
	if len(state.Filtered[[.ResourceNamePlural]]) == 0 {
		state.TotalPages = 1
		state.CurrentPage = 1
		state.Paginated[[.ResourceNamePlural]] = [][[.ResourceName]]Item{}
		return state
	}

	state.TotalPages = int(math.Ceil(float64(len(state.Filtered[[.ResourceNamePlural]])) / float64(state.PageSize)))

	if state.CurrentPage < 1 {
		state.CurrentPage = 1
	}
	if state.CurrentPage > state.TotalPages {
		state.CurrentPage = state.TotalPages
	}

	start := (state.CurrentPage - 1) * state.PageSize
	end := start + state.PageSize
	if end > len(state.Filtered[[.ResourceNamePlural]]) {
		end = len(state.Filtered[[.ResourceNamePlural]])
	}

	state.Paginated[[.ResourceNamePlural]] = state.Filtered[[.ResourceNamePlural]][start:end]
	return state
}

func formatTime() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// Handler creates an http.Handler for this resource
func Handler(queries *models.Queries) http.Handler {
	// Controller is a singleton that holds dependencies
	controller := &[[.ResourceName]]Controller{
		Queries: queries,
	}

	// Initial state is pure data, cloned per session
	initialState := &[[.ResourceName]]State{
		Title:          "[[.ResourceName]] Management",
		CurrentPage:    1,
		PageSize:       [[.PageSize]],
		PaginationMode: "[[.PaginationMode]]",
		LoadedCount:    [[if or (eq .PaginationMode "infinite") (eq .PaginationMode "load-more")]][[.PageSize]][[else]]0[[end]],
		LastUpdated:    formatTime(),
		CSSFramework:   "[[.CSSFramework]]",
	}

	baseTmpl := livetemplate.Must(livetemplate.New("[[.ResourceNameLower]]", livetemplate.WithDevMode([[.DevMode]])))
	if _, err := baseTmpl.ParseFiles("app/[[.ResourceNameLower]]/[[.ResourceNameLower]].tmpl"); err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

[[- if eq .EditMode "page"]]
	// Page mode: Support URL-based routing for resource detail and edit views
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Parse resource ID from URL path (e.g., /products/product-123 or /products/product-123/edit)
		urlPath := strings.TrimPrefix(r.URL.Path, "/[[.ResourceNameLower]]")
		urlPath = strings.TrimPrefix(urlPath, "/")

		if urlPath != "" && r.Method == http.MethodGet {
			// Check if this is an edit URL (/products/:id/edit)
			isEditMode := strings.HasSuffix(urlPath, "/edit")
			if isEditMode {
				urlPath = strings.TrimSuffix(urlPath, "/edit")
			}

			// Extract resource ID
			resourceID := strings.Split(urlPath, "/")[0]
			if resourceID == "" {
				// Invalid URL, fall back to list view
				tmpl, err := baseTmpl.Clone()
				if err != nil {
					log.Printf("Failed to clone template: %v", err)
					http.Error(w, "Internal server error", http.StatusInternalServerError)
					return
				}
				tmpl.Handle(controller, livetemplate.AsState(initialState)).ServeHTTP(w, r)
				return
			}

			// Create state with EditingID and IsEditingMode set for this specific URL
			resourceState := &[[.ResourceName]]State{
				Title:          "[[.ResourceName]] Management",
				CurrentPage:    1,
				PageSize:       [[.PageSize]],
				PaginationMode: "[[.PaginationMode]]",
				LoadedCount:    [[if or (eq .PaginationMode "infinite") (eq .PaginationMode "load-more")]][[.PageSize]][[else]]0[[end]],
				LastUpdated:    formatTime(),
				CSSFramework:   "[[.CSSFramework]]",
				IsEditingMode:  isEditMode,
			}

			// Find and set the editing resource
			[[.ResourceNameLower]]s, err := queries.GetAll[[.ResourceNamePlural]](context.Background())
			if err == nil {
				for _, item := range [[.ResourceNameLower]]s {
					if item.ID == resourceID {
						resourceState.EditingID = resourceID
						itemCopy := item
						resourceState.Editing[[.ResourceName]] = &itemCopy
						break
					}
				}
			}

			// Mount with custom state for this URL
			tmpl, err := baseTmpl.Clone()
			if err != nil {
				log.Printf("Failed to clone template: %v", err)
				http.Error(w, "Internal server error", http.StatusInternalServerError)
				return
			}
			tmpl.Handle(controller, livetemplate.AsState(resourceState)).ServeHTTP(w, r)
			return
		}

		// Default: list view
		tmpl, err := baseTmpl.Clone()
		if err != nil {
			log.Printf("Failed to clone template: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}
		tmpl.Handle(controller, livetemplate.AsState(initialState)).ServeHTTP(w, r)
	})
[[- else]]
	// Modal mode: clone template per request
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		tmpl, err := baseTmpl.Clone()
		if err != nil {
			log.Printf("Failed to clone template: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}
		tmpl.Handle(controller, livetemplate.AsState(initialState)).ServeHTTP(w, r)
	})
[[- end]]
}
