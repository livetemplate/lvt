package user

import (
	"context"
	"fmt"
	"log"
	"math"
	"net/http"
	"sort"
	"strings"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/livetemplate/livetemplate"
	"testmodule/database/models"
)

var validate = validator.New()

type UserItem = models.User

type AddInput struct {
	Name string `json:"name" validate:"required,min=3"`
	Age int64 `json:"age" validate:"required"`
}

type UpdateInput struct {
	ID string `json:"id" validate:"required"`
	Name string `json:"name" validate:"required,min=3"`
	Age int64 `json:"age" validate:"required"`
}

type DeleteInput struct {
	ID string `json:"id" validate:"required"`
}

type SearchInput struct {
	Query string `json:"query"`
}

type SortInput struct {
	SortBy string `json:"sort_by"`
}

type PaginationInput struct {
	Page int `json:"page" validate:"required,min=1"`
}

// UserController is a singleton that holds dependencies (DB, logger, etc.)
type UserController struct {
	Queries *models.Queries
}

// UserState is pure data, cloned per session
type UserState struct {
	Title        string                `json:"title"`
	SearchQuery  string                `json:"search_query"`
	SortBy       string                `json:"sort_by"`
	FilteredUsers  []UserItem `json:"filtered_users"`
	CurrentPage  int                   `json:"current_page"`
	PageSize     int                   `json:"page_size"`
	TotalPages   int                   `json:"total_pages"`
	PaginatedUsers []UserItem `json:"paginated_users"`
	TotalCount   int                   `json:"total_count"`
	LastUpdated  string                `json:"last_updated"`
	EditingID    string                `json:"editing_id" lvt:"transient"`
	EditingUser *UserItem   `json:"editing_user" lvt:"transient"`
	IsEditingMode bool                 `json:"is_editing_mode"` // For page mode: true when at /resource/:id/edit
	PaginationMode string              `json:"pagination_mode"` // "infinite", "load-more", "prev-next", "numbers"
	LoadedCount    int                 `json:"loaded_count"`    // For infinite/load-more modes
	HasMore        bool                `json:"has_more"`        // Whether more items available
	IsLoading      bool                `json:"is_loading"`      // Loading indicator
	CSSFramework   string              `json:"-"`               // CSS framework for templates
	// Sort reversion protection: morphdom can trigger spurious change events
	PrevSortBy   string                `json:"prev_sort_by" lvt:"transient"`   // Previous sort value before last change
	LastSortTime int64                 `json:"last_sort_time" lvt:"transient"` // Unix nano of last sort action
}

// Add handles the "add" action to create a new resource
func (c *UserController) Add(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input AddInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	log.Printf("[lvt debug] add input: %+v", input)

	now := time.Now()
	id := fmt.Sprintf("user-%d", now.UnixNano())

	_, err := c.Queries.CreateUser(dbCtx, models.CreateUserParams{
		ID:        id,
		Name: input.Name,
		Age: input.Age,
		CreatedAt: now,
	})
	if err != nil {
		return state, fmt.Errorf("failed to create user: %w", err)
	}

	state, err = c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Edit handles the "edit" action to start editing a resource
func (c *UserController) Edit(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	// Find the item to edit
	users, err := c.Queries.GetAllUsers(dbCtx)
	if err != nil {
		return state, fmt.Errorf("failed to load users: %w", err)
	}

	for _, item := range users {
		if item.ID == input.ID {
			state.EditingID = input.ID
			itemCopy := item
			state.EditingUser = &itemCopy
			break
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Update handles the "update" action to save changes to a resource
func (c *UserController) Update(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input UpdateInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	err := c.Queries.UpdateUser(dbCtx, models.UpdateUserParams{
		ID: input.ID,
		Name: input.Name,
		Age: input.Age,
	})
	if err != nil {
		return state, fmt.Errorf("failed to update user: %w", err)
	}

	// For page mode: Exit edit mode and stay on detail view
	state.IsEditingMode = false

	// Reload the updated resource
	state, err = c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	// Close modal / clear editing state after successful save
	state.EditingID = ""
	state.EditingUser = nil

	state.LastUpdated = formatTime()
	return state, nil
}

// CancelEdit handles the "cancel_edit" action to cancel editing
func (c *UserController) CancelEdit(state UserState, _ *livetemplate.Context) (UserState, error) {
	state.EditingID = ""
	state.EditingUser = nil
	state.LastUpdated = formatTime()
	return state, nil
}

// View handles the "view" action to view a resource
func (c *UserController) View(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	// Find the item to view/edit
	users, err := c.Queries.GetAllUsers(dbCtx)
	if err != nil {
		return state, fmt.Errorf("failed to load users: %w", err)
	}

	for _, item := range users {
		if item.ID == input.ID {
			state.EditingID = input.ID
			itemCopy := item
			state.EditingUser = &itemCopy
			break
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Back handles the "back" action to return to list view
func (c *UserController) Back(state UserState, _ *livetemplate.Context) (UserState, error) {
	state.EditingID = ""
	state.EditingUser = nil
	state.LastUpdated = formatTime()
	return state, nil
}

// Delete handles the "delete" action to remove a resource
func (c *UserController) Delete(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input DeleteInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	err := c.Queries.DeleteUser(dbCtx, input.ID)
	if err != nil {
		return state, fmt.Errorf("failed to delete user: %w", err)
	}

	// Clear editing state (for page mode)
	state.EditingID = ""
	state.EditingUser = nil

	state, err = c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Search handles the "search" action to filter resources
func (c *UserController) Search(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input SearchInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}
	state.SearchQuery = input.Query
	// Reset infinite scroll when searching
	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		state.LoadedCount = state.PageSize
	}

	state, err := c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Sort handles the "sort" action to sort resources
func (c *UserController) Sort(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input SortInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}

	now := time.Now().UnixNano()

	// Detect and ignore spurious morphdom-triggered reversions:
	// If we receive a value that equals the previous value, and it's within 500ms of the last change,
	// this is likely a spurious event from morphdom updating the select element
	if state.LastSortTime > 0 {
		elapsed := now - state.LastSortTime
		elapsedMs := elapsed / 1_000_000
		if input.SortBy == state.PrevSortBy && elapsedMs < 500 {
			return state, nil
		}
	}

	// Track previous value and update
	state.PrevSortBy = state.SortBy
	state.SortBy = input.SortBy
	state.LastSortTime = now
	// Note: Don't reset LoadedCount when sorting - keep all loaded items visible
	// Just re-sort the existing items for better UX

	state, err := c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// NextPage handles the "next_page" action for pagination
func (c *UserController) NextPage(state UserState, _ *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	if state.CurrentPage < state.TotalPages {
		state.CurrentPage++
	}
	state, err := c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// PrevPage handles the "prev_page" action for pagination
func (c *UserController) PrevPage(state UserState, _ *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	if state.CurrentPage > 1 {
		state.CurrentPage--
	}
	state, err := c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// GotoPage handles the "goto_page" action to jump to a specific page
func (c *UserController) GotoPage(state UserState, ctx *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	var input PaginationInput
	if err := ctx.BindAndValidate(&input, validate); err != nil {
		return state, err
	}
	if input.Page >= 1 && input.Page <= state.TotalPages {
		state.CurrentPage = input.Page
	}
	state, err := c.loadUsers(state, dbCtx)
	if err != nil {
		return state, err
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// LoadMore handles the "load_more" action for infinite scroll
func (c *UserController) LoadMore(state UserState, _ *livetemplate.Context) (UserState, error) {
	dbCtx := context.Background()

	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		if state.HasMore && !state.IsLoading {
			state.IsLoading = true
			state.LoadedCount += state.PageSize
			var err error
			state, err = c.loadUsers(state, dbCtx)
			if err != nil {
				return state, err
			}
			state.IsLoading = false
		}
	}

	state.LastUpdated = formatTime()
	return state, nil
}

// Mount is called once when a new session is created
func (c *UserController) Mount(state UserState, _ *livetemplate.Context) (UserState, error) {
	return c.loadUsers(state, context.Background())
}

func (c *UserController) loadUsers(state UserState, ctx context.Context) (UserState, error) {
	users, err := c.Queries.GetAllUsers(ctx)
	if err != nil {
		return state, fmt.Errorf("failed to load users: %w", err)
	}

	if state.SearchQuery == "" {
		state.FilteredUsers = users
	} else {
		state.FilteredUsers = []UserItem{}
		query := strings.ToLower(state.SearchQuery)
		for _, item := range users {
			// Search across all text fields
			if strings.Contains(strings.ToLower(item.Name), query) {
				state.FilteredUsers = append(state.FilteredUsers, item)
				continue
			}
		}
	}

	state.TotalCount = len(users)
	state = applySorting(state)
	state = applyPagination(state)

	return state, nil
}

// applySorting sorts the filtered items in-place based on the SortBy field.
// Note: sort.Slice mutates the slice in place. This is safe because:
// 1. State is cloned per session via AsState (JSON serialization creates fresh slices)
// 2. The slice is populated fresh from the database in each load operation
// 3. State is passed by value and returned, not shared across sessions
func applySorting(state UserState) UserState {
	switch state.SortBy {
	case "name_asc":
		sort.Slice(state.FilteredUsers, func(i, j int) bool {
			return strings.ToLower(state.FilteredUsers[i].Name) < strings.ToLower(state.FilteredUsers[j].Name)
		})
	case "name_desc":
		sort.Slice(state.FilteredUsers, func(i, j int) bool {
			return strings.ToLower(state.FilteredUsers[i].Name) > strings.ToLower(state.FilteredUsers[j].Name)
		})
	case "oldest_first":
		sort.Slice(state.FilteredUsers, func(i, j int) bool {
			return state.FilteredUsers[i].CreatedAt.Before(state.FilteredUsers[j].CreatedAt)
		})
	default:
		sort.Slice(state.FilteredUsers, func(i, j int) bool {
			return state.FilteredUsers[i].CreatedAt.After(state.FilteredUsers[j].CreatedAt)
		})
	}
	return state
}

func applyPagination(state UserState) UserState {
	if state.PaginationMode == "infinite" || state.PaginationMode == "load-more" {
		return applyInfiniteScroll(state)
	}
	return applyPagedNavigation(state)
}

func applyInfiniteScroll(state UserState) UserState {
	// Initialize LoadedCount if not set
	if state.LoadedCount == 0 {
		state.LoadedCount = state.PageSize
	}

	if len(state.FilteredUsers) == 0 {
		state.PaginatedUsers = []UserItem{}
		state.HasMore = false
		return state
	}

	// Load items from 0 to LoadedCount
	end := state.LoadedCount
	if end > len(state.FilteredUsers) {
		end = len(state.FilteredUsers)
	}

	state.PaginatedUsers = state.FilteredUsers[0:end]
	state.HasMore = end < len(state.FilteredUsers)
	return state
}

func applyPagedNavigation(state UserState) UserState {
	if len(state.FilteredUsers) == 0 {
		state.TotalPages = 1
		state.CurrentPage = 1
		state.PaginatedUsers = []UserItem{}
		return state
	}

	state.TotalPages = int(math.Ceil(float64(len(state.FilteredUsers)) / float64(state.PageSize)))

	if state.CurrentPage < 1 {
		state.CurrentPage = 1
	}
	if state.CurrentPage > state.TotalPages {
		state.CurrentPage = state.TotalPages
	}

	start := (state.CurrentPage - 1) * state.PageSize
	end := start + state.PageSize
	if end > len(state.FilteredUsers) {
		end = len(state.FilteredUsers)
	}

	state.PaginatedUsers = state.FilteredUsers[start:end]
	return state
}

func formatTime() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// Handler creates an http.Handler for this resource
func Handler(queries *models.Queries) http.Handler {
	// Controller is a singleton that holds dependencies
	controller := &UserController{
		Queries: queries,
	}

	// Initial state is pure data, cloned per session
	initialState := &UserState{
		Title:          "User Management",
		CurrentPage:    1,
		PageSize:       20,
		PaginationMode: "infinite",
		LoadedCount:    20,
		LastUpdated:    formatTime(),
		CSSFramework:   "tailwind",
	}

	baseTmpl := livetemplate.Must(livetemplate.New("user", livetemplate.WithDevMode(false)))
	if _, err := baseTmpl.ParseFiles("app/user/user.tmpl"); err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}
	// Modal mode: clone template per request
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		tmpl, err := baseTmpl.Clone()
		if err != nil {
			log.Printf("Failed to clone template: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}
		tmpl.Handle(controller, livetemplate.AsState(initialState)).ServeHTTP(w, r)
	})
}
